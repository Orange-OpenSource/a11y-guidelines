<!doctype html>
<html lang="en" dir="ltr" class="no-js">
  <head>
    <meta charset="utf-8">
    <title>iOS developer guide - Orange digital accessibility guidelines</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="preconnect" href="https://code.jquery.com" crossorigin="anonymous">
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin="anonymous">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin="anonymous">
    <link rel="preload" href="/assets/fonts/HelvNeue55_W1G.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="/assets/fonts/HelvNeue75_W1G.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    
    <link rel="apple-touch-icon" href="/assets/images/apple-touch-icon.png" sizes="180x180">
    <link rel="icon" href="/assets/images/favicon-32x32.png" sizes="32x32" type="image/png">
    <link rel="icon" href="/assets/images/favicon-16x16.png" sizes="16x16" type="image/png">
    <link rel="mask-icon" href="/assets/images/safari-pinned-tab.svg" color="#563d7c">
    <link rel="icon" href="/assets/images/favicon.ico">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/boosted@4.5.2/dist/css/boosted.min.css" integrity="sha384-j8BgukP8/Cao3CDMrwvCOSDGFQr7Yr3LGW9PUWByAoJuSwmgppSVBjC8rOSubbeC" crossorigin="anonymous">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.1/build/styles/a11y-light.min.css">
    
    <link rel="stylesheet" href="/assets/style.css">
    <link rel="stylesheet" href="/assets/tarteaucitron-boosted.css"></head>
  <body>
    

<header role="banner">
  <div class="navbar navbar-dark navbar-expand supra">
    <div class="container-lg">
      <nav role="navigation" aria-label="Skip links">
  <ul class="navbar-nav"><li class="nav-item">
        <a href="#main-menu" class="nav-link">Go to menu</a>
      </li><li class="nav-item">
        <a href="#main-content" class="nav-link">Go to content</a>
      </li><li class="nav-item">
        <a href="#footer" class="nav-link">Go to footer</a>
      </li></ul>
</nav>

      <nav role="navigation" aria-label="Switch language">
  <ul class="navbar-nav">
      <li class="nav-item">
        <a href="/en/" class="nav-link active" aria-current="true" lang="en">
        English
        </a>
      </li>
      <li class="nav-item">
        <a href="/fr/" class="nav-link" lang="fr">
        Français
        </a>
      </li></ul>
</nav>
    </div>
  </div>
  

<div class="navbar navbar-dark navbar-expand-md">
  <nav id="main-menu" class="container-lg justify-content-md-start" role="navigation" aria-label="Main navigation">
    <a href="/en" class="navbar-brand" title="Orange, go to homepage">
      <img src="/assets/images/orange-logo.svg" alt="Orange, go to homepage" width="50" height="50">
    </a>

    <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#main-menu-list" aria-controls="main-menu-list" aria-expanded="false" aria-label="Navigation menu">
      <span class="navbar-toggler-icon"></span>
    </button>

    <ul id="main-menu-list" class="navbar-nav navbar-collapse collapse"><li class="nav-item">
          <a href="/en/" class="nav-link">
  Home
</a>
        </li><li class="nav-item">
          <a href="/en/planning/" class="nav-link">
  Planning
</a>
        </li><li class="nav-item">
          <a href="/en/web/" class="nav-link">
  Web
</a>
        </li><li class="nav-item">
          <a href="/en/mobile/android/" class="nav-link">
  Android
</a>
        </li><li class="nav-item">
          <a href="/en/mobile/ios/" class="nav-link active" aria-current="true">
  iOS
</a>
        </li><li class="nav-item">
          <a href="/en/editorial-content/" class="nav-link">
  Editorial content
</a>
        </li><li class="nav-item">
          <a href="/en/articles/" class="nav-link">
  Articles
</a>
        </li><li class="nav-item d-md-none">
  <span class="sr-only">Switch language</span>
  <ul class="d-flex list-inline">
      <li class="list-inline-item flex-grow-1">
        <a href="/en/" class="nav-link active" aria-current="true" lang="en">
        English
        </a>
      </li>
      <li class="list-inline-item flex-grow-1">
        <a href="/fr/" class="nav-link" lang="fr">
        Français
        </a>
      </li></ul>
</li>
    </ul>
  </nav>
</div>

  <nav id="secondary-navigation" class="o-nav-local navbar-light mb-1" role="navigation" aria-label="Secondary navigation">
  <div class="container-lg">
    <ul class="nav"><li class="nav-item">
              <a href="/en/mobile/ios/design/" class="nav-link">
  Design
</a>
            </li><li class="nav-item">
              <a href="/en/mobile/ios/development/" class="nav-link active" aria-current="page">
  Develop
</a>
            </li><li class="nav-item">
              <a href="/en/mobile/ios/test/" class="nav-link">
  Test
</a>
            </li><li class="nav-item">
              <a href="/en/mobile/ios/toolbox/" class="nav-link">
  Toolbox
</a>
            </li><li class="nav-item">
              <a href="/en/mobile/ios/wwdc/" class="nav-link">
  WWDC
</a>
            </li></ul>
  </div>
</nav>
</header>

    <div class="container-lg pt-2">
      
      
        

<nav role="navigation" aria-labelledby="breadcrumb-label">
  <p id="breadcrumb-label" class="sr-only">You are here:</p>
  <ol class="breadcrumb">
      
        <li class="breadcrumb-item d-none d-sm-flex">
          <a href="/en/">Home</a>
        </li>
      
      
        <li class="breadcrumb-item">
          <a href="/en/mobile/ios/">iOS</a>
        </li>
      
      
        <li class="breadcrumb-item d-none d-sm-flex" aria-current="location">
          Develop
        </li>
      </ol>
</nav>

      
      <div class="MobileDropdownNavigationContainer d-flex flex-column flex-sm-row justify-content-between">
        
        
      </div>
    </div>
    
  <main id="main-content" class="container-lg pt-4" role="main">
      <h1>iOS developer guide</h1>
<p>This guide aims to present the various iOS <abbr>SDK</abbr> accessibility options.<br>
<br>Through different categories, it explains how to use the accessibility attributes / methods and provides links to the <a href="https://developer.apple.com/documentation/uikit/accessibility"><code>Apple official documentation</code></a>.<br>
<br>Code snippets are also available to show the different possible implementations <em>{ (Swift 5.1, Objective C) + (Xcode 11, iOS 13) }</em>.</p>
<p><a name="AccessibilityTraits"></a></p>
<h2 id="element-trait">Element trait <a class="header-anchor" href="#element-trait" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#TraitElt-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#TraitElt-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#TraitElt-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#TraitElt-BasicOperations" 
           role="tab" 
           aria-selected="false">Basic operations</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#TraitElt-Links" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="TraitElt-Description"
     role="tabpanel">
<p>The <code>accessibilityTraits</code> attribute allows to specify the trait of an element to the accessibility <abbr>API</abbr>.<br>
<br>Then, the <code>accessibilityTrait</code> attribute <strong>plays an important role on the element vocalization</strong> because it enables VoiceOver to recognize its type.</p>
</div>
<div class="tab-pane" id="TraitElt-Details" role="tabpanel">
<p>This accessibility attribute is available via the interface builder but also programmatically.<br>
<br><br>There are many available traits. The most commonly used are:</p>
<ul>
<li><strong>accessibilityTraitNone</strong> : removes any semantic value to the element.</li>
<li><strong>accessibilityTraitButton</strong> : adds the “button” trait, the element is seen as a button by VoiceOver.</li>
<li><strong>accessibilityTraitLink</strong> : useful to define a label as a “link”.</li>
<li><strong>accessibilityTraitHeader</strong> : defines an element as a header <em>(see the <a href="../design#title-and-header">« Title and header »</a> section)</em>.</li>
<li><strong>accessibilityTraitAdjustable</strong> : defines an element as an “adjustable” element, that is to say an element that users can adjust in a continuous manner, such as a slider or a picker view <em>(see the <a href="../voiceover">VoiceOver user guide</a>)</em>.</li>
</ul>
</div>
<div class="tab-pane" id="TraitElt-Example" role="tabpanel">
<pre><code class="objective-c">
- (void)customTraits() {
    //Specified UIPageControl with the ’ajustable’ trait.
    pageControl.accessibilityTraits = UIAccessibilityTraitAdjustable;
    
    //Added header.  
    defaultHeaderViewCell.accessibilityTraits = UIAccessibilityTraitHeader;
}
</code></pre>
<pre><code class="swift">
func customTraits() {
    //Specified UIPageControl with the ’ajustable’ trait.
    pageControl.accessibilityTraits = .adjustable
    
    //Added header.  
    defaultHeaderViewCell.accessibilityTraits = .header
}
</code></pre>
</div>
<div class="tab-pane" id="TraitElt-BasicOperations" role="tabpanel">
<p>The <code>accessibilityTrait</code> attribute is actually a <code>bitmask</code> in which each element has its own value.<br>
<br><img alt="" style="max-width: 600px; height: auto; " src="../../images/iOSdev/Traits.png" /><br>
<br>It's then possible to add and remove some <code>traits</code> after having checked their existence in the bitmask for instance.</p>
<pre><code class="objective-c">
- (void)changeTraits {

    //Dedicated trait set with no other option.
    onePageButton.accessibilityTraits = UIAccessibilityTraitButton | UIAccessibilityTraitLink;
    
    //Added traits to the existing ones.
    pageControl.accessibilityTraits |= UIAccessibilityTraitHeader; //Only one trait.
    pageControl.accessibilityTraits |= UIAccessibilityTraitButton + UIAccessibilityTraitLink; //Many traits.
    
    //Remove a trait.
    onePageButton.accessibilityTraits &= ~UIAccessibilityTraitLink;
    
    //Check out the bitmask trait existence.
    if ((pageControl.accessibilityTraits & UIAccessibilityTraitHeader) != 0) {
        // Do the job if '.header' is one of the traits...
    }
}
</code></pre>
<pre><code class="swift">
func changeTraits() {
        
    //Dedicated trait set with no other option.
    onePageButton.accessibilityTraits = [.button, .link]
        
    //Added traits to the existing ones.
    pageControl.accessibilityTraits.insert(.header) //Only one trait.
    pageControl.accessibilityTraits.formUnion([.button, .link]) //Many traits.
        
    //Remove a trait.
    onePageButton.accessibilityTraits.remove(.link)
        
    //Check out the bitmask trait existence.
    if (pageControl.accessibilityTraits.rawValue & UIAccessibilityTraits.header.rawValue == UIAccessibilityTraits.header.rawValue) {
        // Do the job if '.header' is one of the traits...
    }
}
</code></pre>
</div>
<div class="tab-pane" id="TraitElt-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615202-accessibilitytraits"><code>accessibilityTraits</code></a></li>
</ul>
</div>
</div><br><br>
<h2 id="text-alternatives">Text alternatives <a class="header-anchor" href="#text-alternatives" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#textAlt-Details" 
           role="tab" 
           aria-selected="true">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#textAlt-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#textAlt-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="textAlt-Details"
     role="tabpanel">
<p>On iOS, the vocalization of an element is done through four attributes: <code>label</code>, <code>hint</code>, <code>value</code> and <code>trait</code>.<br>
The order of vocalization is always as follows: <code>label</code>, <code>value</code>, <code>trait</code> and <code>hint</code>. This order cannot be changed and the vocalization is performed only once.<br>
<br><br>A section of this guide is dedicated to the <a href="#AccessibilityTraits" style="text-decoration: underline;">trait</a>, we describe here the other three:</p>
<ul>
<li><strong>accessibilityLabel</strong> : the <code>label</code> redefines the text read by VoiceOver. This allows a component to be more explicit than the text displayed on the screen. For example, for a button whose title is “OK”, this attribute can indicate that the button is used to confirm an action.</li>
<li><strong>accessibilityValue</strong> : the <code>value</code> of an element is by default the completion percentage (e.g. a progress bar percentage). Note that for most elements available in the <abbr>SDK</abbr>, this value does not need to be set (the system automatically sets the value).</li>
<li><strong>accessibilityHint</strong> : the <code>hint</code> describes the component’s behaviour. Example: “click here to get the result”.</li>
</ul>
<p>These accessibility attributes are available via the builder interface but also programmatically. Anything inheriting from <code>UIView</code> has these attributes by default. These attributes accept an optional string, and are therefore easily localizable.</p>
</div>
<div class="tab-pane" id="textAlt-Example" role="tabpanel">
<pre><code class="objective-c">
@interface ChangeTextView() {
    
    __weak IBOutlet UILabel * myLabel;
    __weak IBOutlet UIProgressView * myProgressView;
}
@end

@implementation ChangeTextView

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    
    myLabel.accessibilityLabel = @"hello";
    myLabel.accessibilityHint = @"This is an added comment.";
    
    myProgressView.accessibilityValue = @"45 per cent";
}
@end
</code></pre>
<pre><code class="swift">
class ChangeTextView: UIViewController {

    @IBOutlet weak var myLabel: UILabel!
    @IBOutlet weak var myProgressView: UIProgressView!
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        myLabel.accessibilityLabel = "hello"
        myLabel.accessibilityHint = "This is an added comment."
        
        myProgressView.accessibilityValue = "45 per cent"
        
    }
}
</code></pre>
</div>
<div class="tab-pane" id="textAlt-Links" role="tabpanel"> 
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615181-accessibilitylabel"><code>accessibilityLabel</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615117-accessibilityvalue"><code>accessibilityValue</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615093-accessibilityhint"><code>accessibilityHint</code></a></li>
<li><a href="../wwdc/2019#WritingGreatAccessibilityLabels">Writing Great Accessibility Labels</a></li>
</ul>
</div>
</div><br><br>
<h2 id="date-time-and-numbers">Date, time and numbers <a class="header-anchor" href="#date-time-and-numbers" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#format-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#format-DateTime" 
           role="tab" 
           aria-selected="false">Date & Time</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#format-Numbers" 
           role="tab" 
           aria-selected="false">Numbers</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#format-PhoneNumbers" 
           role="tab" 
           aria-selected="false">Phone numbers</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="format-Description"
     role="tabpanel">
<p>Using VoiceOver for reading date, time and numbers may become rapidly a headache if some steps fade into obscurity.</p>
</div>
<div class="tab-pane" id="format-DateTime" role="tabpanel">
<p>The rendering isn't natural if the date or time data are imported text in a <code>label</code>.<br>
<br><img alt="" style="max-width: 800px; height: auto; " src="../../images/iOSdev/DateHeureNombres_11.png" /><br>
<br>Incoming data must be formatted to obtain a natural and understandable descriptive vocalization.<br>
<br><img alt="" style="max-width: 800px; height: auto; " src="../../images/iOSdev/DateHeureNombres_7.png" /></p>
<pre><code class="objective-c">
    NSDateFormatter * dateFormatter = [[NSDateFormatter alloc]init];
    [dateFormatter setDateFormat:@"dd/MM/yyyy HH:mm"];
    
    NSDate * date = [dateFormatter dateFromString:@"01/04/2015 05:30"];
    
    dateLabel.text = [NSDateFormatter localizedStringFromDate:date
                                                    dateStyle:NSDateFormatterShortStyle
                                                    timeStyle:NSDateFormatterNoStyle];
    
    dateLabel.accessibilityLabel = [NSDateFormatter localizedStringFromDate:date
                                                                  dateStyle:NSDateFormatterMediumStyle
                                                                  timeStyle:NSDateFormatterNoStyle];

    
    hourLabel.text = [NSDateFormatter localizedStringFromDate:date
                                                    dateStyle:NSDateFormatterNoStyle
                                                    timeStyle:NSDateFormatterShortStyle];
    
    NSDateComponents * hourComponents = [[NSCalendar currentCalendar] components:NSCalendarUnitHour | NSCalendarUnitMinute
                                                                        fromDate:date];
                                                                        
    hourLabel.accessibilityLabel = [NSDateComponentsFormatter localizedStringFromDateComponents:hourComponents
                                                                                     unitsStyle:NSDateComponentsFormatterUnitsStyleSpellOut];
</code></pre>
<pre><code class="swift">
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "dd/MM/yyyy HH:mm"
        
    let date = dateFormatter.date(from: "01/04/2015 05:30")
        
    dateLabel.text = DateFormatter.localizedString(from: date!,
                                                   dateStyle: .short,
                                                   timeStyle: .none)
                                                       
    dateLabel.accessibilityLabel = DateFormatter.localizedString(from: date!,
                                                                 dateStyle: .medium,
                                                                 timeStyle: .none)
        
        
    hourLabel.text = DateFormatter.localizedString(from: date!,
                                                   dateStyle: .none,
                                                   timeStyle: .short)
        
    let hourComponents = Calendar.current.dateComponents([.hour, .minute],
                                                         from: date!)
    hourLabel.accessibilityLabel = DateComponentsFormatter.localizedString(from: hourComponents,
                                                                           unitsStyle: .spellOut)
</code></pre>
</div>
<div class="tab-pane" id="format-Numbers" role="tabpanel">
<p>If a number is imported as is in a <code>label</code>text, the vocalization will be made on each figure rendering a final value that may be hard to be well understood.<br>
<br><img alt="" style="max-width: 475px; height: auto; " src="../../images/iOSdev/DateHeureNombres_12.png" /><br>
<br>As the previous sheet dealing with date and time, the incoming data must be formatted to be analyzed and vocalized according to the proper value of the explained number.<br>
<br><img alt="" style="max-width: 700px; height: auto; " src="../../images/iOSdev/DateHeureNombres_8.png" /></p>
<pre><code class="objective-c">
    NSNumber * numberValue = @54038921.7;
    
    NSNumberFormatter * numberFormatter = [[NSNumberFormatter alloc]init];
    numberFormatter.numberStyle = NSNumberFormatterDecimalStyle;
    
    numberLabel.text = [numberFormatter stringFromNumber:numberValue];
    
    numberLabel.accessibilityLabel = [NSNumberFormatter localizedStringFromNumber:numberValue
                                                                      numberStyle:NSNumberFormatterSpellOutStyle];
</code></pre>
<pre><code class="swift">
    let numberValue = NSNumber(value: 54038921.7)
        
    numberLabel.text = NumberFormatter.localizedString(from: numberValue,
                                                       number: .decimal)
                                                           
    numberLabel.accessibilityLabel = NumberFormatter.localizedString(from: numberValue,
                                                                     number: .spellOut)
</code></pre>
</div>
<div class="tab-pane" id="format-PhoneNumbers" role="tabpanel">
<p>Once more, formatting data is an essential step for a phone number vocalization including the special cases of the &quot;0&quot; figures.<br>
<br>The example hereunder deals with the french dialing but the rationale behind may be applied to any international type of dialing format.<br>
<br><img alt="default vocalization is not valid for the following phone number : 06.11.22.33.06" style="max-width: 550px; height: auto; " src="../../images/iOSdev/DateHeureNombres_10.png" /><br>
<br>The idea of this format is based on a comma separation of each pair of figures that will provide the vocal punctuation.<br>
<br><img alt="in this case the phone number is well vocalized" style="max-width: 550px; height: auto; " src="../../images/iOSdev/DateHeureNombres_9.png" /></p>
<pre><code class="objective-c">
    NSString * phoneNumberValue = @"06.11.22.33.06";
    NSArray * phoneNumberElts = [phoneNumberValue componentsSeparatedByString:@"."];
    
    NSNumberFormatter * nbFormatter = [[NSNumberFormatter alloc]init];
    nbFormatter.numberStyle = NSNumberFormatterSpellOutStyle;
    
    NSMutableString * spelledOutString = [[NSMutableString alloc]init];
    
    [phoneNumberElts enumerateObjectsUsingBlock:^(id  _Nonnull obj,
                                                  NSUInteger idx,
                                                  BOOL * _Nonnull stop) {
        NSString * elt = (NSString *)obj;
        
        if (idx != 0) {
            [spelledOutString appendString:@","];
        }
        
        if ([elt hasPrefix:@"0"]) {
            
            NSString * firstFigure = [nbFormatter stringFromNumber:@([[elt substringToIndex:1] integerValue])];
            NSString * secondFigure = [nbFormatter stringFromNumber:@([[elt substringFromIndex:1] integerValue])];
            
            [spelledOutString appendString:firstFigure];
            [spelledOutString appendString:secondFigure];
            
        } else {
            [spelledOutString appendString:[nbFormatter stringFromNumber:@([elt integerValue])]];
        }
    }];
    
    phoneNumberLabel.text = phoneNumberValue;
    phoneNumberLabel.accessibilityLabel = spelledOutString;
</code></pre>
<pre><code class="swift">
        let phoneNumberValue = "06.11.22.33.06"
        let phoneNumberElts = phoneNumberValue.components(separatedBy: ".")
        
        let nbFormatter = NumberFormatter()
        nbFormatter.numberStyle = .spellOut
        
        var spelledOutString = String()
        
        for (index, elt) in phoneNumberElts.enumerated() {
            
            if (index != 0) {
                spelledOutString.append(",")
            }
            
            if (elt.hasPrefix("0")) {
                
                let firstFigureValue = Int(String(elt[elt.startIndex]))!
                let firstFigure = nbFormatter.string(from: NSNumber(value:firstFigureValue))
                spelledOutString.append(firstFigure!)
                
                let secondFigureValue = Int(String(elt[elt.index(elt.startIndex, offsetBy: 1)]))!
                let secondFigure = nbFormatter.string(from: NSNumber(value:secondFigureValue))
                spelledOutString.append(secondFigure!)
                
            } else {
                
                let figure = nbFormatter.string(from: NSNumber(value:Int(elt)!))
                spelledOutString.append(figure!)
            }
        }

        phoneNumberLabel.text = phoneNumberValue
        phoneNumberLabel.accessibilityLabel = spelledOutString
</code></pre>
</div>
</div><br><br>
<h2 id="trigger-a-vocalization">Trigger a vocalization <a class="header-anchor" href="#trigger-a-vocalization" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#triggerVocal-Details" 
           role="tab" 
           aria-selected="true">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#triggerVocal-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#triggerVocal-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="triggerVocal-Details"
     role="tabpanel">
<p>To trigger a vocalization, just call the <strong>UIAccessibilityPostNotification</strong> method passing the notification allowing to trigger a vocalization (<strong>UIAccessibilityAnnouncementNotification</strong>) and the string to vocalize as parameters.<br>
<br><br>Note: the vocalization is done in the system’s language.</p>
</div>
<div class="tab-pane" id="triggerVocal-Example" role="tabpanel">
<pre><code class="objective-c">
UIAccessibilityPostNotification(UIAccessibilityAnnouncementNotification, 
                                @"This is a VoiceOver message.");
</code></pre>
<pre><code class="swift">
UIAccessibility.post(notification: .announcement,
                     argument: "This is a VoiceOver message.")
</code></pre>
</div>
<div class="tab-pane" id="triggerVocal-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/1615194-uiaccessibilitypostnotification"><code>UIAccessibilityPostNotification</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilityannouncementnotification"><code>UIAccessibilityAnnouncementNotification</code></a></li>
</ul>
</div>
</div><br><br>
<h2 id="change-the-vocalization-language">Change the vocalization language <a class="header-anchor" href="#change-the-vocalization-language" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#changeLang-Details" 
           role="tab" 
           aria-selected="true">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#changeLang-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#changeLang-Links" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="changeLang-Details"
     role="tabpanel">
<p>To change the vocalization language of VoiceOver for a word or a sentence, one can use the <strong>accessibilityLanguage</strong>  attribute.<br>
<br>Available through the <code>UIAccessibility</code> informal protocol, this attribute allows to specify a language for a dedicated text.</p>
</div>
<div class="tab-pane" id="changeLang-Example" role="tabpanel">
<p>If we use the <code>accessibilityLanguage</code> attribute on a <code>UILabel</code>, it will be vocalized by <span lang="en">VoiceOver</span> in the language set on this attribute.</p>
<pre><code class="objective-c">
- (IBAction)tapHere:(UIButton *)sender {
    
    myLabel.accessibilityLanguage = @"fr";
    myLabel.accessibilityLabel = @"Ceci est un nouveau label. Merci.";
    UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);
}
</code></pre>
<pre><code class="swift">
@IBAction func tapHere(_ sender: UIButton) {
        
    myLabel.accessibilityLanguage = "fr"
    myLabel.accessibilityLabel = "Ceci est un nouveau label. Merci."
    UIAccessibility.post(notification: UIAccessibility.Notification.layoutChanged,
                         argument: myLabel)
}
</code></pre>
</div>
<div class="tab-pane" id="changeLang-Links" role="tabpanel">  
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615192-accessibilitylanguage"><code>accessibilityLanguage</code></a></li>
</ul>
</div>
</div><br><br>
<h2 id="notify-a-content-change">Notify a content change <a class="header-anchor" href="#notify-a-content-change" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#changeNotif-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#changeNotif-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#changeNotif-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#changeNotif-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="changeNotif-Description"
     role="tabpanel">
<p>When there is a content change in the current page, it is possible to notify the accessibility <abbr>API</abbr> using several types of notifications.<br>
<br>To do that, we must send the change notification to the accessibility <abbr>API</abbr> using the following <code>UIAccessibilityPostNotification</code> method.</p>
</div>
<div class="tab-pane" id="changeNotif-Details" role="tabpanel">
<p>There are several types of change notifications but the most two commonly used are:</p>
<ul>
<li><strong>UIAccessibilityLayoutChangedNotification</strong> : notifies that a part of the page has changed with 2 possible incoming parameters (a <code>NSString</code> or a <code>UIObject</code>).<br>
<br>With a <code>NSString</code>, the notification behaves like a <strong>UIAccessibilityAnnouncementNotification</strong> with a <span lang="en">VoiceOver</span> vocalization.<br>
<br>With a <code>UIObject</code>, focus is shifted to the user interface element.<br>
<br>This notification is very similar to the <strong>UIAccessibilityAnnouncementNotification</strong> but should come as a result of dynamic content being deleted or added to the current view.</li>
<li><strong>UIAccessibilityScreenChangedNotification</strong> : notifies that the whole page has changed including <code>nil</code> or a <code>UIObject</code> as incoming parameters.<br>
With <code>nil</code>, the first accessible element in the page is focused.<br>
<br>With a <code>UIObject</code>, focus is shifted to the specified element with a <span lang="en">VoiceOver</span>.<br>
<br>This notification comes along with a vocalization including a sound like announcing a new page.</li>
</ul>
</div>
<div class="tab-pane" id="changeNotif-Example" role="tabpanel">
<pre><code class="objective-c">
//The element 'myLabel' is focused and vocalized with its new value.
- (IBAction)tapHere:(UIButton *)sender {
    
    myLabel.accessibilityLabel = @"This is a new label.";
    UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);
}

//The first accessible element in the page is focused and vocalized with a sound like announcing a new page.
- (IBAction)clic:(UIButton *)sender {
    
    UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, nil);
}
</code></pre>
<pre><code class="swift">
//The element 'myLabel' is focused and vocalized with its new value.
@IBAction func tapHere(_ sender: UIButton) {
        
    myLabel.accessibilityLabel = "This is a new label."
    UIAccessibility.post(notification: UIAccessibility.Notification.layoutChanged,
                         argument: myLabel)
}
    
//The first accessible element in the page is focused and vocalized with a sound like announcing a new page.
@IBAction func clic(_ sender: UIButton) {
        
    UIAccessibility.post(notification: UIAccessibility.Notification.screenChanged,
                         argument: nil)
}
</code></pre>
</div>
<div class="tab-pane" id="changeNotif-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/1615194-uiaccessibilitypostnotification"><code>UIAccessibilityPostNotification</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitylayoutchangednotification"><code>UIAccessibilityLayoutChangedNotification</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilityscreenchangednotification"><code>UIAccessibilityScreenChangedNotification</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitypagescrollednotification"><code>UIAccessibilityPageScrolledNotification</code></a></li>
</ul>
</div>
</div><br><br>
<p><a name="MaskElements"></a></p>
<h2 id="hide-elements">Hide elements <a class="header-anchor" href="#hide-elements" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#hideElts-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#hideElts-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#hideElts-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#hideElts-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="hideElts-Description"
     role="tabpanel">
<p>It is possible via an accessibility attribute to hide elements from accessibility tools (e.g. VoiceOver).<br>
<br>By extension, it is possible to force some elements to be visible to accessibility tools.</p>
</div>
<div class="tab-pane" id="hideElts-Details" role="tabpanel">
<ul>
<li><strong>isAccessibilityElement</strong>: boolean to specify that an element is visible or not to the Accessibility <abbr>API</abbr> (VoiceOver or other).</li>
<li><strong>accessibilityElementsHidden</strong>: boolean to indicate that the children elements of the target element are visible or not to the Accessibility <abbr>API</abbr>.</li>
<li><strong>accessibilityViewIsModal</strong>: boolean that can make visible or not the sibling elements of the target element to the Accessibility <abbr>API</abbr>.<br>
<br>A <a href="../wwdc/2018/230#accessibilityViewIsModal">theoretical explanation</a> and a <a href="../wwdc/2018/230#DemoModalView">practical example</a> are provided in a video detailed in the WWDC part.<br>
  <br>
The <code>accessibilityElement</code> attribute is available via the interface builder but can also be used directly through the code.<br>
<br>The other two attributes are available only through the code.</li>
</ul>
</div>
<div class="tab-pane" id="hideElts-Example" role="tabpanel">
<p>A red square will be drawn and contain two other squares (blue and yellow) in order to apply the attributes defined in the <code>Details</code> sheet.</p>
<img alt="" style="max-width: 500px; height: auto; " src="../../images/iOSdev/MasquerDesElements_1.png" />
<pre><code class="objective-c">
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    
    //Creation of an element inside which 2 other children elements will be inserted.
    CGRect redParentViewRect = CGRectMake(100.0, 100.0, 40.0, 40.0);
    UIView * myRedParentView = [[UIView alloc]initWithFrame:redParentViewRect];
    myRedParentView.backgroundColor = [UIColor redColor];
    
    [self.view addSubview:myRedParentView];
    
    //The target element musn't be accessible so as to be considered as a container to its children elements.
    //If this attribute is 'YES', the target element will be the only one accessible element.
    myRedParentView.isAccessibilityElement = NO;
    
    //The elements contained in the target element won't be accessible even if they're defined as such.
    //If this attribute is 'NO' and the previous one is 'NO', only the children elements will be accessible.
    myRedParentView.accessibilityElementsHidden = NO;
    
    [self createViewWithColor:[UIColor yellowColor] 
                       inside:myRedParentView];
    [self createViewWithColor:[UIColor blueColor] 
                       inside:myRedParentView];
}

- (void)createViewWithColor:(UIColor*)color
                     inside:(UIView*)parentView {
    
    float delta = (color == [UIColor yellowColor]) ? 0.0 : 20.0;
    
    CGRect rect = CGRectMake(10.0 + delta, 10.0 + delta, 10.0, 10.0);
    UIView * theView = [[UIView alloc]initWithFrame:rect];
    theView.backgroundColor = color;
    
    [parentView addSubview:theView];
    
    theView.isAccessibilityElement = YES;
}
</code></pre>
<pre><code class="swift">
override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        //Creation of an element inside which 2 other children elements will be inserted.
        let redParentViewRect = CGRect.init(x: 100.0,
                                            y: 100.0,
                                            width: 40.0,
                                            height: 40.0)
        let myParentView = UIView.init(frame: parentViewRect)
        myRedParentView.backgroundColor = .red
        
        self.view.addSubview(myRedParentView)
        
        //The target element musn't be accessible so as to be considered as a container to its children elements.
        //If this attribute is 'true', the target element will be the only one accessible element.
        myRedParentView.isAccessibilityElement = true
        
        //The elements contained in the target element won't be accessible even if they're defined as such.
        //If this attribute is 'false' and the previous one is 'false', only the children elements will be accessible.
        myRedParentView.accessibilityElementsHidden = false
        
        self.createViewWithColor(.yellow, inside: myRedParentView)
        self.createViewWithColor(.blue, inside: myRedParentView)
    }
    
    func createViewWithColor(_ color:UIColor, inside parentView:UIView) {
        
        let delta:CGFloat = ((color == .yellow) ? 0.0 : 20.0)
        let rect = CGRect.init(x: 10.0 + delta,
                               y: 10.0 + delta,
                               width: 10.0,
                               height: 10.0)
        
        let theView = UIView.init(frame: rect)
        theView.backgroundColor = color
        
        parentView.addSubview(theView)
        
        theView.isAccessibilityElement = true
    }
</code></pre>
</div>
<div class="tab-pane" id="hideElts-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615141-isaccessibilityelement"><code>isAccessibilityElement</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615080-accessibilityelementshidden"><code>accessibilityElementsHidden</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615089-accessibilityviewismodal"><code>accessibilityViewIsModal</code></a></li>
</ul>
</div>
</div><br><br>
<h2 id="grouping-elements">Grouping elements <a class="header-anchor" href="#grouping-elements" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#groupElts-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#groupElts-Example1" 
           role="tab" 
           aria-selected="false">Example 1</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#groupElts-Example2" 
           role="tab" 
           aria-selected="false">Example 2</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#groupElts-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="groupElts-Description"
     role="tabpanel">
<p>Grouping elements may be used to vocalize the bundle once and to associate a dedicated action to it.<br><br></p>
</div>
<div class="tab-pane" id="groupElts-Example1" role="tabpanel">
<p>We wish to obtain a 'label' and a 'switch control' as one unique block behaving like a <code>switch control</code>.<br>
<br>In this case, a view must be created to encapsulate all the elements and an action must be implemented (only the container must be an accesible element).<br>
<br><img alt="" style="max-width: 700px; height: auto; " src="../../images/iOSdev/GrouperDesElements_1.png" /><br>
<br>Create your wrapper as an accessible element :</p>
<pre><code class="objective-c">
#import "MyViewController.h"
#import "MyWrapView.h"

@interface MyViewController ()

@property (weak, nonatomic) IBOutlet UILabel * myLabel;
@property (weak, nonatomic) IBOutlet UISwitch * mySwitch;

@end


@implementation MyViewController

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    
    //Create the view that will encapsulate the 'label' and the 'Switch Control'.
    MyWrapView * wrap = [[MyWrapView alloc] initWith:_myLabel
                                                 and:_mySwitch];
    
    [self.view addSubview:wrap];
}
@end
</code></pre>
<pre><code class="swift">
    class MyViewController: UIViewController {

    @IBOutlet weak var myLabel: UILabel!
    @IBOutlet weak var mySwitch: UISwitch!
    
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        //Create the view that will encapsulate the 'label' and the 'Switch Control'.
        let wrap = MyWrapView.init(with: myLabel,
                                   and: mySwitch)
        
        self.view.addSubview(wrap)
    }
}
</code></pre>
<p><br>... and implement the wrapper class to define accurately the<br>
<a href="../wwdc/2017/215#DefaultActivation">action when a double tap occurs</a> :</p>
<pre><code class="objective-c">
@implementation MyWrapView

//Indexes for the array containing all the wrapped elements.
int indexLabel = 0;
int indexSwitch = 1;


- (instancetype)initWith:(UILabel *)label and:(UISwitch *)aSwitch {
    
    CGRect viewFrame = CGRectUnion(label.frame, aSwitch.frame);
    MyWrapView * wrapView = [[MyWrapView alloc]initWithFrame:viewFrame];
    
    wrapView.accessibilityElements = @[label, aSwitch];
    
    NSString * switchValue = (aSwitch.isOn) ? @"on" : @"off";
    
    wrapView.isAccessibilityElement = YES;
    wrapView.accessibilityLabel = [NSString stringWithFormat:@"the switch control is %@", switchValue.description];
    wrapView.accessibilityHint = @"tap twice to change the switch control status.";
    
    return wrapView;
}


//Function called by the system when a double tap occurs on the selected wrapper.
- (BOOL)accessibilityActivate {
    
    UISwitch * theSwitch = self.accessibilityElements[indexSwitch];
    [theSwitch setOn:!(theSwitch.isOn)];
    
    NSString * switchValue = (theSwitch.isOn) ? @"on" : @"off";
    
    self.accessibilityLabel = [NSString stringWithFormat:@"the switch control is %@", switchValue.description];
    return YES;
}
@end
</code></pre>
<pre><code class="swift">
    class MyWrapView: UIView {
    
    //Indexes for the array containing all the wrapped elements.
    let indexLabel = 0
    let indexSwitch = 1
    
    
    override init(frame: CGRect) {
        super.init(frame: frame)
    }
    
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
    }
    
    
    convenience init(with label: UILabel,and aSwitch: UISwitch) {
        
        let viewFrame = label.frame.union(aSwitch.frame)
        self.init(frame: viewFrame)
        
        self.accessibilityElements = [label, aSwitch]
        
        let switchValue = (aSwitch.isOn) ? "on" : "off"
        
        self.isAccessibilityElement = true
        self.accessibilityLabel = "the switch control is " + switchValue.description
        self.accessibilityHint = "tap twice to change the switch control status."
    }
    
    
    //Function called by the system when a double tap occurs on the selected wrapper.
    override func accessibilityActivate() -> Bool {
        
        let theSwitch = self.accessibilityElements?[indexSwitch] as? UISwitch
        theSwitch?.setOn(!((theSwitch?.isOn)!), animated: false)
        
        let switchValue = (theSwitch?.isOn)! ? "on" : "off"
        
        self.accessibilityLabel = "the switch control is " + switchValue.description
        
        return true
    }
}
</code></pre>
</div>
<a name="ActivationPointExemple"></a>
<div class="tab-pane" id="groupElts-Example2" role="tabpanel">
<p>We have a button, a label and a switch control to be regrouped in a single block whose activation will change the switch control status automatically without defining any action like before.<br>
<br><br>The easiest way would be to place the switch control in the middle of the created frame in order to locate its <a href="#AccessibilityActivationPoint">accessibilityActivationPoint</a> directly on it.<br>
<br>Unfortunately, that's not always possible.<br>
<br><br>A new accessible element must then be created to gather all the desired objects and its <strong>accessibilityActivationPoint</strong> has to be defined on the switch control.<br>
<br><img alt="" style="max-width: 350px; height: auto; " src="../../images/iOSdev/GrouperDesElements_2.png" /></p>
<pre><code class="objective-c">
@interface ActivationPointViewController ()

@property (weak, nonatomic) IBOutlet UIButton * myButton;
@property (weak, nonatomic) IBOutlet UILabel * myLabel;
@property (weak, nonatomic) IBOutlet UISwitch * mySwitch;

@end


@implementation ActivationPointViewController

UIAccessibilityElement * elt;

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    
    [_mySwitch addTarget:self
                  action:@selector(configChanged:)
        forControlEvents:UIControlEventValueChanged];
    
    elt = [[UIAccessibilityElement alloc]initWithAccessibilityContainer:self.view];
    
    CGRect a11yFirstEltFrame = CGRectUnion(_myLabel.frame, _myButton.frame);
    CGRect a11yEltFrame = CGRectUnion(a11yFirstEltFrame, _mySwitch.frame);
    
    elt.accessibilityLabel = @"regrouping elements";
    elt.accessibilityHint = @"double tap to change the switch control status";
    elt.accessibilityFrameInContainerSpace = a11yEltFrame;
    elt.accessibilityActivationPoint = [_mySwitch center];
    
    self.view.accessibilityElements = @[elt];
}
  
    
- (void)configChanged:(UISwitch *)sender {
 
    NSString * switchValue = _mySwitch.on ? @"on" : @"off";
    elt.accessibilityLabel = [NSString stringWithFormat:@"the switch control is %@", switchValue.description];
}
@end
</code></pre>
<pre><code class="swift">
    class ActivationPointViewController: UIViewController {
    
    @IBOutlet weak var myButton: UIButton!
    @IBOutlet weak var myLabel: UILabel!
    @IBOutlet weak var mySwitch: UISwitch!
    
    var elt: UIAccessibilityElement?
    
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        mySwitch.addTarget(self,
                           action: #selector(configChanged),
                           for: .valueChanged)
        
        elt = UIAccessibilityElement(accessibilityContainer: self.view!)
        let a11yEltFrame = (myLabel.frame.union(myButton.frame)).union(mySwitch.frame)
        
        if let elt = elt {
            
            elt.accessibilityLabel = "regrouping elements"
            elt.accessibilityHint = "double tap to change the switch control status"
            elt.accessibilityFrameInContainerSpace = a11yEltFrame
            elt.accessibilityActivationPoint = mySwitch.center
            
            self.view.accessibilityElements = [elt]
        }
    }
    
    
    @objc func configChanged(sender: UISwitch){
        
        if let configGroup = elt {
            
            let switchValue = (mySwitch?.isOn)! ? "on" : "off"
            configGroup.accessibilityLabel = "the switch control is " + switchValue.description
        }
    }
}
</code></pre>
<p>Another grouping elements case could use the <strong>shouldGroupAccessibilityChildren</strong> attribute which is a Boolean that indicates whether <span lang="en">VoiceOver</span> must group its children views.<br>
<br>This allows making unique vocalizations or define a particular reading order for a part of the page <em>(see <a href="#ReadingOrder">Reading order</a> section for further information)</em>.</p>
</div>
<div class="tab-pane" id="groupElts-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615165-accessibilityactivate"><code>accessibilityActivate</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615143-shouldgroupaccessibilitychildren"><code>shouldGroupAccessibilityChildren</code></a></li>
</ul>
</div>
</div><br><br>
<a name="ReadingOrder"></a>
<h2 id="reading-order">Reading order <a class="header-anchor" href="#reading-order" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#readingOrder-Details" 
           role="tab" 
           aria-selected="true">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#readingOrder-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#readingOrder-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="readingOrder-Details"
     role="tabpanel">
<p>Redefining the VoiceOver reading order is done using the <strong>UIAccessibilityContainer</strong> protocol: the idea is to have a table of elements that defines the reading order of the elements.<br>
<br><br>It is often very useful to use the <strong>shouldGroupAccessibilityElement</strong> attribute so we have a precise order but only for a part of the view <em>(the rest of it will be read using the native order provided by VoiceOver)</em>.</p>
</div>
<div class="tab-pane" id="readingOrder-Example" role="tabpanel">
<p>The best way to illustrate this feature is the keyboard whose keys order isn't necessary the appropriate one.<br>
<br>Here's the desired order : 1, 2, 3, 4, 7, 6, 8, 9, 5.<br>
<br><br>Two views are created containing the numbers to be spelled out in a specific order:<br>
<br><img alt="display of the blue and grey views" style="max-width: 500px; height: auto; " src="../../images/iOSdev/OrdreDeLecture_1.png" /></p>
<pre><code class="objective-c">
    __weak IBOutlet UIView * blueBlock;
    __weak IBOutlet UIView * greyColumn;
    
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    
    //Reads the first three numbers in the grey column.
    greyColumn.shouldGroupAccessibilityChildren = YES;
    
    //Reads 6, 8, 9 and 5 in this order inside the blue block.
    blueBlock.isAccessibilityElement = NO;
    blueBlock.accessibilityElements = @[key_6,
                                        key_8,
                                        key_9,
                                        key_5];
}
</code></pre>
<pre><code class="swift">
    @IBOutlet weak var greyColumn: UIView!
    @IBOutlet weak var blueBlock: UIView!
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        //Reads the first three numbers in the grey column.
        greyColumn.shouldGroupAccessibilityChildren = true
        
        //Reads 6, 8, 9 and 5 in this order inside the blue block.
        blueBlock.isAccessibilityElement = false
        blueBlock.accessibilityElements = [key_6!,
                                           key_8!,
                                           key_9!,
                                           key_5!]
    }
</code></pre>
</div>
<div class="tab-pane" id="readingOrder-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/accessibility/uiaccessibilitycontainer?language=objc"><code>UIAccessibilityContainer</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615143-shouldgroupaccessibilitychildren"><code>shouldGroupAccessibilityChildren</code></a></li>
</ul>
</div>
</div><br><br>
<h2 id="focus-an-element">Focus an element <a class="header-anchor" href="#focus-an-element" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#focusElt-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusElt-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusElt-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusElt-Links" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="focusElt-Description"
     role="tabpanel">
<p>The <strong>UIAccessibilityFocus</strong> informal protocol provides programming elements to be informed of the accessible element focus.</p>
</div>
<div class="tab-pane" id="focusElt-Details" role="tabpanel">
<ul>
<li><strong>accessibilityElementDidBecomeFocused</strong> : called when the accessible element is focused.</li>
<li><strong>accessibilityElementDidLoseFocus</strong> : fired when the accessible element lost focus.</li>
<li><strong>accessibilityElementIsFocused</strong> : boolean value indicating the accessible element selection.</li>
</ul>
<p>Overriden inside a view controller, these elements will be helpless if you think they will be called when an accessible element is focused.<br>
<br>However, if they are <strong>implemented in the accessible element itself</strong>, you won't be disappointed.<br>
<br><br>This mistake is due to the informal aspect of the protocol that allows an override of its methods inside an inherited NSObject element even if it's not accessible... like a view controller for instance.</p>
</div>
<div class="tab-pane" id="focusElt-Example" role="tabpanel">
<p>The example below enables to follow the focus of an accessible element identified by its <code>accessibleIdentifier</code>.</p>
<pre><code class="objective-c">
#import "UIView+focus.h"

@implementation UIView (focus)

- (void)accessibilityElementDidBecomeFocused {
    
    if ([self accessibilityElementIsFocused]) {
        NSLog(@"My element has become focused.");
    }
}

- (void)accessibilityElementDidLoseFocus {
    
    if ([self accessibilityElementIsFocused]) {
        NSLog(@"My element has lost focus.");
    }
}

- (BOOL)accessibilityElementIsFocused {
    
    if ([self.accessibilityIdentifier isEqualToString:@"myAccessibleElt"]) {
        return YES;
    } else {
        return NO;
    }
}
@end
</code></pre>
<pre><code class="swift">
extension UIView {
    override open func accessibilityElementDidBecomeFocused() {
        
        if self.accessibilityElementIsFocused() {
            print("My element has become focused.")
        }
    }
    
    override open func accessibilityElementDidLoseFocus() {
        
        if self.accessibilityElementIsFocused() {
            print("My element has lost focus.")
        }
    }
    
    override open func accessibilityElementIsFocused() -> Bool {
        
        if (self.accessibilityIdentifier == "myAccessibleElt") {
            return true
        } else {
            return false
        }
    }
}
</code></pre>
</div>
<div class="tab-pane" id="focusElt-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/accessibility/uiaccessibilityfocus"><code>UIAccessibilityFocus</code></a></li>
</ul>
</div>
</div><br><br>
<h2 id="modify-the-focus-area-of-voiceover">Modify the focus area of VoiceOver <a class="header-anchor" href="#modify-the-focus-area-of-voiceover" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#focusArea-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusArea-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusArea-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusArea-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="focusArea-Description"
     role="tabpanel">
<p>In the case of dynamically modified element or component not inheriting from <code>UIView</code>, it is possible to modify the focus area of accessibility of this element, i.e. the area <span lang="en">VoiceOver</span> highlights when focusing an element.</p>
</div>
<div class="tab-pane" id="focusArea-Details" role="tabpanel">
<ul>
<li><strong>accessibilityFrame</strong> : sets the area via a rectangle (<code>CGRect</code>).<br>
<br>Usually, for an element inheriting from <code>UIView</code>, this area is the « visible » part of the view.</li>
<li><strong>accessibilityPath</strong> : equivalent to <code>accessibilityFrame</code> but sets the area via Bezier curves.<br>
<a name="AccessibilityActivationPoint"></a></li>
<li><strong>accessibilityActivationPoint</strong> : defines a contact point inside the <code>frame</code> whose action will be fired by a double-tap element activation.<br>
<br>The default value is the midpoint of the <code>frame</code> but it can be redefine anywhere inside.<br>
<br>A classical use case could be an easy activation inside a <a href="#ActivationPointExemple">regroupment of elements</a> for instance.<br>
<br><img alt="" style="max-width: 350px; height: auto; " src="../../images/iOSdev/ModifierLaZoneDeFocus_2.png" /><br>
<br>By keeping this default value, one might unwillingly activate the element in the middle of the frame only by activating the created regroupment.</li>
</ul>
</div>
<div class="tab-pane" id="focusArea-Example" role="tabpanel">
<img alt="" style="max-width: 700px; height: auto; " src="../../images/iOSdev/ModifierLaZoneDeFocus_1.png" />
<pre><code class="objective-c">
float xVal;
float yVal;
float widthVal;
float heightVal;
<ul>
<li>
<p>(void)viewDidAppear:(BOOL)animated {<br>
[super viewDidAppear:animated];</p>
<p>xVal = myLabel.accessibilityFrame.origin.x;<br>
yVal = myLabel.accessibilityFrame.origin.y;<br>
widthVal = myLabel.accessibilityFrame.size.width;<br>
heightVal = myLabel.accessibilityFrame.size.height;</p>
</li>
</ul>
<p>}</p>
<p>//First way to enlarge the focus area.</p>
<ul>
<li>
<p>(IBAction)tapHere:(UIButton *)sender {</p>
<p>myLabel.accessibilityFrame = CGRectMake(xVal,<br>
yVal,<br>
widthVal + 100.0,<br>
heightVal+ 100.0);</p>
<p>UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);<br>
}</p>
</li>
</ul>
<p>//Second way to enlarge the focus area (Bezier).</p>
<ul>
<li>
<p>(IBAction)clic:(UIButton *)sender {</p>
<p>UIBezierPath * bezierPath = [UIBezierPath bezierPath];</p>
<p>[bezierPath moveToPoint:CGPointMake(xVal, yVal)];</p>
<p>[bezierPath addLineToPoint:CGPointMake(xVal + widthVal + 100.0,<br>
yVal)];<br>
[bezierPath addLineToPoint:CGPointMake(xVal + widthVal + 100.0,<br>
yVal + heightVal+ 100.0)];<br>
[bezierPath addLineToPoint:CGPointMake(xVal,<br>
yVal + heightVal+ 100.0)];<br>
[bezierPath closePath];</p>
<p>myLabel.accessibilityPath = bezierPath;</p>
<p>UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);<br>
}<br>
</code></pre></p>
</li>
</ul>
<pre><code class="swift">
    var xVal: CGFloat = 0.0
    var yVal: CGFloat = 0.0
    var widthVal: CGFloat = 0.0
    var heightVal: CGFloat = 0.0
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        xVal = myLabel.accessibilityFrame.origin.x;
        yVal = myLabel.accessibilityFrame.origin.y;
        widthVal = myLabel.accessibilityFrame.size.width;
        heightVal = myLabel.accessibilityFrame.size.height;
    }
    
    //First way to enlarge the focus area.
    @IBAction func clicHere(_ sender: UIButton) {
        
        myLabel.accessibilityFrame = CGRect.init(x: xVal,
                                                 y: yVal,
                                                 width: widthVal + 100.0,
                                                 height: heightVal + 100.0)
        
        UIAccessibility.post(notification: UIAccessibility.Notification.layoutChanged,
                             argument: myLabel)
    }
    
    //Second way to enlarge the focus area (Bezier).
    @IBAction func clic(_ sender: UIButton) {
        
        let bezierPath = UIBezierPath.init()
        
        bezierPath.move(to: CGPoint.init(x: xVal, y: yVal))
        
        bezierPath.addLine(to: CGPoint.init(x: xVal + widthVal + 100.0,
                                            y: yVal))
        bezierPath.addLine(to: CGPoint.init(x: xVal + widthVal + 100.0,
                                            y: yVal + heightVal + 100.0))
        bezierPath.addLine(to: CGPoint.init(x: xVal,
                                            y: yVal + heightVal + 100.0))
        bezierPath.close()
        
        myLabel.accessibilityPath = bezierPath
        
        UIAccessibility.post(notification: UIAccessibility.Notification.screenChanged,
                             argument: myLabel)
    }
</code></pre>
</div>
<div class="tab-pane" id="focusArea-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilityelement/1619579-accessibilityframe"><code>accessibilityFrame</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615159-accessibilitypath"><code>accessibilityPath</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615179-accessibilityactivationpoint"><code>accessibilityActivationPoint</code></a></li>
</ul>
</div>
</div><br><br>
<h2 id="modal-view">Modal view <a class="header-anchor" href="#modal-view" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#modalView-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#modalView-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#modalView-Example"
           id="modalView-Example_tab"
           role="tab" 
           aria-selected="false">Examples</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#modalView-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="modalView-Description"
     role="tabpanel">
<p>When a view is presented modally <em>(alert, popup...)</em>, the screen reader must only analyze its elements and definitely not those still present in the background.<br>
<br>To reach this goal, you must put the <strong><a href="../wwdc/2018/230#accessibilityViewIsModal">accessibilityViewIsModal</a></strong> property value to <code>true</code> to be sure that VoiceOver only takes care of the appropriate instance elements.</p>
</div>
<div class="tab-pane" id="modalView-Details" role="tabpanel">
<p>Writing <code>accessibilityViewIsModal = true</code> may not be enough to get the intended read out because of the views hierarchy.<br>
<br>Indeed, <strong>only the impacted view siblings</strong> aren't taken into account by VoiceOver, all the other ones are.<br>
<br><br>If the explanations provided in the <a role="button" onclick="$('#modalView-Example_tab').trigger('click');document.getElementById('modalView').scrollIntoView({ behavior: 'smooth', block: 'start' })">Examples</a> tab aren't detailed enough, take a look at this <a href="http://ronnqvi.st/adding-accessible-behavior">David RÖNNQVIST article</a> containing a pedagogical and interactive illustration that explains how the modal view process works <em>('Implementing accessible modal views' section)</em>.</p>
</div>
<div class="tab-pane" id="modalView-Example" role="tabpanel">
<p>Hereafter, knowledge about hiding wrappers and their contents is assumed to be acquired: if further information is needed, please refer to the <strong><a href="#MaskElements">Hide elements</a></strong> section to feel comfortable with this notion.<br>
<br><br>For the examples, let's assume we have a main view containting the following accessible elements :</p>
<ul>
<li>A first view <em>(parent A)</em> with 3 subviews <em>(A1, A2, A3)</em>.</li>
<li>A second view <em>(parent B)</em> with a sublevel <em>(B1 et B2)</em> containing subviews <em>(B1.1, B1.2, B2.1, B2.2 et B3.3)</em>.<br>
<br><br><img alt="" style="max-width: 900px; height: auto; " src="../../images/iOSdev/ModalView_1.png" /></li>
</ul>
<p><strong>Example 1</strong> : <code>Parent A</code> view as modal.<br>
<br>Because <code>Parent B</code> is a <code>Parent A</code> sibling, <code>accessibilityViewIsModal = true</code> is enough to get the desired result.<br>
<br><br><br><strong>Example 2</strong> : <code>A2</code> view as modal.<br>
<br><code>A1</code> and <code>A3</code> aren't taken into account by VoiceOver because they're <code>A2</code> siblings <strong>BUT</strong> <code>Parent B</code> <em>(or possibly its subviews)</em> will be vocalized... and that's definitely not the goal.<br>
<br><img alt="" style="max-width: 700px; height: auto; " src="../../images/iOSdev/ModalView_3.png" /><br>
<br>In order to figure out this problem, hiding the undesirable elements when the view is activated as modal is the solution to be applied.</p>
<pre><code class="objective-c">
    parentA.isAccessibilityElement = NO;
    parentA.accessibilityElementsHidden = NO;

    A2.accessibilityViewIsModal = YES;
        
    //Resolves the problem with Parent B and its subviews.
    parentB.isAccessibilityElement = NO;
    parentB.accessibilityElementsHidden = YES;
</code></pre>
<pre><code class="swift">
    parentA.isAccessibilityElement = false
    parentA.accessibilityElementsHidden = false

    A2.accessibilityViewIsModal = true
        
    //Resolves the problem with Parent B and its subviews.
    parentB.isAccessibilityElement = false
    parentB.accessibilityElementsHidden = true
</code></pre>
<p><br><strong>Example 3</strong> : <code>B1.1</code> view as modal.<br>
<br>In this case, <code>parent A</code> and <code>B2</code> <em>(or possibly their subviews)</em> are vocalized with the modal view: only <code>B1.2</code> isn't read out by VoiceOver because it's <code>B1.1</code> sibling.<br>
<br><img alt="" style="max-width: 900px; height: auto; " src="../../images/iOSdev/ModalView_4.png" /><br>
<br>Again, all the undesirable elements must be hidden as soon as the modal view is activated as modal.</p>
<pre><code class="objective-c">
    parentB.isAccessibilityElement = NO;
    parentB.accessibilityElementsHidden = NO;

    B1.isAccessibilityElement = NO;
    B1.accessibilityElementsHidden = NO;

    B11.accessibilityViewIsModal = YES;

    //Resolves the problem with Parent A and B2.
    parentA.isAccessibilityElement = NO;
    parentA.accessibilityElementsHidden = YES;

    B2.isAccessibilityElement = NO;
    B2.accessibilityElementsHidden = YES;
</code></pre>
<pre><code class="swift">
    parentB.isAccessibilityElement = false
    parentB.accessibilityElementsHidden = false

    B1.isAccessibilityElement = false
    B1.accessibilityElementsHidden = false

    B11.accessibilityViewIsModal = true

    //Resolves the problem with Parent A and B2.
    parentA.isAccessibilityElement = false
    parentA.accessibilityElementsHidden = true

    B2.isAccessibilityElement = false
    B2.accessibilityElementsHidden = true
</code></pre>
</div>
<div class="tab-pane" id="modalView-Links" role="tabpanel">
<ul>
<li><a href="#MaskElements">Hide elements</a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615089-accessibilityviewismodal"><code>accessibilityViewIsModal</code></a></li>
<li><a href="http://ronnqvi.st/adding-accessible-behavior">David Rönnqvist : &quot;Implementing accessible modal views&quot;</a></li>
<li><a href="../wwdc/2018/230#accessibilityViewIsModal">WWDC 2018 : Deliver an exceptional accessibility experience</a></li>
</ul>
</div>
</div><br><br>
<h2 id="text-size">Text size <a class="header-anchor" href="#text-size" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#textSize-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#textSize-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#textSize-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="textSize-Description"
     role="tabpanel">
<p>Since iOS7, it is possible to make the text size dynamic according to the phone settings.</p>
</div>
<div class="tab-pane" id="textSize-Details" role="tabpanel">
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#TextSize-iOS13"
           role="tab" 
           aria-selected="true">iOS 13</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#TextSize-iOS12"
           role="tab" 
           aria-selected="false">iOS 12</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="TextSize-iOS13"
     role="tabpanel">
<img alt="" style="max-width: 950px; height: auto; " src="../../images/iOSdev/TailleDesTextes_iOS13_1.png" />
</div>
<div class="tab-pane" 
     id="TextSize-iOS12" 
     role="tabpanel">
<img alt="" style="max-width: 700px; height: auto; " src="../../images/iOSdev/TailleDesTextes_1.png" />
</div></div>
<p><br>The following steps should be respected in order to easily use this <abbr>API</abbr> :</p>
<ul>
<li><strong>Use the text styles</strong> available with the application iOS version.<br>
<br><img alt="" style="max-width: 400px; height: auto; " src="../../images/iOSdev/TailleDesTextes_2.png" /></li>
<li>Choose the system font to facilitate your programing even if the use of other fonts is well assisted by the <code>UIFontMetrics</code> new class (iOS11).</li>
</ul>
 <pre><code class="objective-c">
    __weak IBOutlet UILabel * fontHeadline;
    __weak IBOutlet UILabel * fontFootNote;
    
    //Use of the default native font.
    fontFootNote.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline];
    
    //Customed font definition for a header.
    UIFont * fontHead = [UIFont fontWithName:@"Chalkduster" size:30.0];
    UIFontMetrics * fontHeadMetrics = [[UIFontMetrics alloc]initForTextStyle:UIFontTextStyleHeadline];
    fontHeadline.font = [fontHeadMetrics scaledFontForFont:fontHead];
</code></pre>
<pre><code class="swift">
    @IBOutlet weak var fontHeadline: UILabel!
    @IBOutlet weak var fontFootNote: UILabel!
    
    //Use of the default native font for a header.
    fontFootNote.font = .preferredFont(forTextStyle: .headline)
        
    //Customed font definition for a header.
    let fontHead = UIFont(name: "Chalkduster", size: 30.0)
    let fontHeadMetrics = UIFontMetrics(forTextStyle: .headline)
    fontHeadline.font = fontHeadMetrics.scaledFont(for: fontHead!)
</code></pre>
<ul>
<li>Listen to the font size settings change event <strong>UIContentSizeCategoryDidChange</strong> or directly use the property <strong>adjustsFontForContentSizeCategory</strong> to have an automatic update of your system font size if you're programming in iOS10 (this attribute applies to custom fonts only with the <code>UIFontMetrics</code> class).<br>
<br>Note that the <strong><a href="../wwdc/2017/245#Demo">traitCollectionDidChange</a></strong> method that belongs to the <code>UITraitEnvironment</code> informal protocol may also be used in this context because it will be called as soon as the iOS interface environment changes <em>(class/content size, portrait/landscape, color contrast)</em>.</li>
</ul>
<pre><code class="objective-c">
    //Listens to the notification dealing with the font size changing from the mobile settings.
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(methodToBeCalled:)
                                                 name:UIContentSizeCategoryDidChangeNotification
                                               object:nil];
    
    //Automatic changing of the font size without listening to the previous notification.
    fontHeadline.adjustsFontForContentSizeCategory = YES;
    
    - (void)methodToBeCalled:(NSNotification *)notification {
    
        //When handling the font size change event, you must redisplay the affected elements.
        fontFootNote.font = [UIFont preferredFontForTextStyle:UIFontTextStyleFootnote];
    }
</code></pre>
<pre><code class="swift">
    //Listens to the notification dealing with the font size changing from the mobile settings.
    NotificationCenter.default.addObserver(self,
                                           selector:#selector(methodToBeCalled(notification:)),
                                           name: UIContentSizeCategory.didChangeNotification,
                                           object: nil)
    
    //Automatic changing of the font size without listening to the previous notification.
    fontHeadline.adjustsFontForContentSizeCategory = true
    
    @objc func methodToBeCalled(notification: Notification) {

        //When handling the font size change event, you must redisplay the affected elements.
        fontFootNote.font = UIFont.preferredFont(forTextStyle: .footnote)
    }
</code></pre>
<ul>
<li>Be careful that the containers fit their contents: using constraints is the best way to perform this task using dynamic values. Don't forget to include the settings for the navigation/tab/status bar and toolbar items that will be handled by the <strong><a href="../wwdc/2019/261/">Large Content Viewer</a></strong>.</li>
<li>Don't forget to adapt the <a href="../design#colours">color contrast</a> to the text size.</li>
</ul>
</div>
<div class="tab-pane" id="textSize-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/typography/">Dynamic Type &amp; Text Styles</a></li>
<li><a href="https://developer.apple.com/documentation/foundation/nsnotification.name/1622948-uicontentsizecategorydidchange"><code>UIContentSizeCategoryDidChange</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uicontentsizecategoryadjusting/1771731-adjustsfontforcontentsizecategor?language=objc"><code>adjustsFontForContentSizeCategory</code></a></li>
<li><a href="../wwdc/2017/245">Building Apps with Dynamic Type</a></li>
</ul>
</div>
</div><br><br>
<h2 id="truncation-hyphen">Truncation hyphen <a class="header-anchor" href="#truncation-hyphen" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#truncHyphen-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#truncHyphen-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="truncHyphen-Description"
     role="tabpanel">
<p>The <code>Dynamic Type</code> feature introduced in the previous section may come along with a word truncation according to the magnifying that is defined in the settings.<br>
<br>Unfortunately, the iOS system doesn't handle natively this point that can be implemented only by programing to get an appreciated visual depiction.</p>
</div>
<div class="tab-pane" id="truncHyphen-Example" role="tabpanel">
<img alt="" style="max-width: 700px; height: auto; " src="../../images/iOSdev/Troncature.png" />
<br>The rationale behind is the use of a `NSMutableAttributedString` with a `NSMutableParagraphStyle` type property as exposed hereunder:
<pre><code class="objective-c">
@interface TruncationHyphen () {
    __weak IBOutlet UILabel * myLabel;
}
@end


@implementation TruncationHyphen

- (void)viewDidLoad {
    [super viewDidLoad];
    
    NSString * myString = @"floccinaucinihilipilification";
    NSMutableParagraphStyle * paraph = [[NSMutableParagraphStyle alloc] init];
    
    paraph.alignment = NSTextAlignmentJustified;
    paraph.hyphenationFactor = 1.0;
    
    UIFont * myFont = [UIFont fontWithName:@"HoeflerText-Black" size:18.0];
    UIFont * myTextFont = [[UIFontMetrics metricsForTextStyle:UIFontTextStyleTitle1] scaledFontForFont:myFont];
    
    NSDictionary * attributesDictionary = @{NSFontAttributeName:myTextFont};
    NSMutableAttributedString * myText = [[NSMutableAttributedString alloc]initWithString:myString 
                                                                               attributes:attributesDictionary];
    
    [myText addAttribute:NSParagraphStyleAttributeName
                   value:paraph
                   range:NSMakeRange(0, 1)];
    
    myLabel.attributedText = myText;
}
@end
</code></pre>
<pre><code class="swift">
class TruncationHyphen: UIViewController {

    @IBOutlet weak var myLabel: UILabel!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        let myString = "floccinaucinihilipilification"
        
        let paraph = NSMutableParagraphStyle()
        paraph.alignment = .justified
        paraph.hyphenationFactor = 1.0
        
        let myTextFont = UIFontMetrics(forTextStyle: .title1).scaledFont(for:UIFont(name:"HoeflerText-Black", size:18)!)
        
        let myText = NSMutableAttributedString(string:myString,
                                               attributes: [.font: myTextFont])
        
        myText.addAttribute(.paragraphStyle,
                            value: paraph,
                            range: NSMakeRange(0,1))

        myLabel.attributedText = myText
    }
}
</code></pre>
</div>
</div><br><br>
<h2 id="graphical-elements-size">Graphical elements size <a class="header-anchor" href="#graphical-elements-size" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#graphEltSize-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#graphEltSize-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#graphEltSize-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="graphEltSize-Description"
     role="tabpanel">
<p>Exactly like text, images and tab/tool bar items have a scalable size thanks to accessibility settings but <strong>only since iOS11 with Xcode 9</strong>.</p>
</div>
<div class="tab-pane" id="graphEltSize-Example" role="tabpanel">
<p>To illustrate these new features, the example below is obtained by following the steps hereafter:<br>
<br><br>1. Under Xcode, import the image to be enlarged with a <code>pdf</code> extension and a x1 resolution in the <code>xcassets</code> catalog.<br>
<br><br>2. In the new Image Set, tick <code>Preserve Vector Data</code> and specify <code>Single Scale</code> as Scales attribute  :<br>
<br><img alt="" style="max-width: 700px; height: auto; " src="../../images/iOSdev/TailleDesEltsGraphiques_4.png" /><br>
<br><br>3. If a storyboard is used for this image, tick <code>Adjusts Image Size</code> in the Image View section, otherwise put the <code>adjustsImageSizeForAccessibilityContentSizeCategory</code> image property to <code>true</code> in code  :<br>
<br><img alt="" style="max-width: 350px; height: auto; " src="../../images/iOSdev/TailleDesEltsGraphiques_5.png" /><br>
<br><br>4. If a <strong>tab bar</strong> or a <strong>tool bar</strong> is used in the application, first repeat the previous 3 steps for each image included in the items to be enlarged in the middle of the screen and then link the image to its appropriate item  :<br>
<br><img alt="" style="max-width: 350px; height: auto; " src="../../images/iOSdev/TailleDesEltsGraphiques_6.png" /><br>
<br><strong>WARNING : don't forget to check out your layout with these new images larger sizes.</strong><br>
<br><br>An application with a tab bar, whose second bar item displays the Orange logo (added <code>Aspect Fit</code> content mode and constraints to stretch the image view), is created to test the features exposed in the description.<br>
<br><br>With the <code>Larger Accessibility Sizes</code> activation in the settings (see <a href="#graphical-elements-size">the previous section</a>), one can easily note in the application  :</p>
<ul>
<li>A larger Orange image size.</li>
<li>A larger version of the bar item in an overlay if you touch and hold over it ⟹ <strong><a href="../wwdc/2019/261/">Large Content Viewer</a></strong> feature available since iOS 11.<br>
<br><img alt="" style="max-width: 1050px; height: auto; " src="../../images/iOSdev/TailleDesEltsGraphiques_9.png" /></li>
</ul>
</div>
<div class="tab-pane" id="graphEltSize-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitycontentsizecategoryimageadjusting/2890929-adjustsimagesizeforaccessibility"><code>adjustsImageSizeForAccessibilityContentSizeCategory</code></a></li>
<li><a href="../wwdc/2019/261/">WWDC 2019 : Large Content Viewer</a></li>
</ul>
</div>
</div><br><br>
<h2 id="large-content-viewer">Large Content Viewer <a class="header-anchor" href="#large-content-viewer" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#largeContentViewer-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#largeContentViewer-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#largeContentViewer-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="largeContentViewer-Description"
     role="tabpanel">
<p>This feature <strong>introduced in iOS 11</strong> allows people with low vision to use UIKit bar elements as effective as the <code>Dynamic Type</code> grows the text size.<br>
<br>To trigger this <strong>Large Content Viewer</strong> <em>(see <a href="#graphical-elements-size">Graphical elements size</a>)</em>, the user must long press the element to see a larger version in the middle of the screen.<br>
<br><br>When implementing the <code>Dynamic Type</code> feature, <strong>iOS 13</strong> allows to show the same UI that's shown for standard UIKit bar items for every element that conforms to the <strong>UILargeContentViewerItem</strong> protocol.<br>
<br><br><img alt="" style="max-width: 900px; height: auto; " src="../../images/iOSdev/LargeContentViewer_1.png" /><br>
<br><br>The following points are important to be noticed before implementing the <code>Large Content Viewer</code> feature :</p>
<ul>
<li>It's important to notice that '<strong>scaling with Dynamic Type is always preferred to showing the Large Content Viewer</strong>' that must be implemented '<strong>only for the case when your custom UI cannot grow in size</strong>' ⟹ <a href="../wwdc/2019/261#LargeContentViewer">Apple recommendation</a>.</li>
<li>This feature is <strong>available only for the the accessibility text sizes</strong>.</li>
</ul>
</div>
<div class="tab-pane" id="largeContentViewer-Example" role="tabpanel">
<p>If an element magnification may lower the user experience, the <code>Large Content Viewer</code> can be implemented on that particular view to get the Head's Up Display in the middle of the screen :<br>
<br><br><img alt="" style="max-width: 900px; height: auto; " src="../../images/iOSdev/LargeContentViewer_2.png" /></p>
<pre><code class="objective-c">
@interface LogoViewController ()
@property (weak, nonatomic) IBOutlet UIImageView * myView;
@end


NS_ASSUME_NONNULL_BEGIN
@implementation LogoViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    _myView.showsLargeContentViewer = YES;
    _myView.largeContentTitle = @"logo";
    _myView.largeContentImage = [UIImage systemImageNamed:@"hand.thumbsup"];
    
    [_myView addInteraction:[[UILargeContentViewerInteraction alloc] init]];
}
@end
NS_ASSUME_NONNULL_END
</code></pre>
<pre><code class="swift">
class LogoViewController: UIViewController {
    
    @IBOutlet weak var myView: UIImageView!
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        myView.isUserInteractionEnabled = true
        
        myView.showsLargeContentViewer = true
        myView.largeContentTitle = "logo"
        myView.largeContentImage = UIImage(systemName: "hand.thumbsup")
        
        myView.addInteraction(UILargeContentViewerInteraction())
    }
}
</code></pre>
<p><br>In the same way, on a <strong>clickable element</strong> like a button whose magnification may become problematic, it's quite possible to use this feature to display its content and to ensure to <strong>trigger its actions when the finger is up</strong> :<br>
<br><img alt="" style="max-width: 900px; height: auto; " src="../../images/iOSdev/LargeContentViewer_3.png" /></p>
<pre><code class="objective-c">
@interface ButtonViewController ()
@property (weak, nonatomic) IBOutlet UIButton * myButton;
@end


NS_ASSUME_NONNULL_BEGIN
@implementation ButtonViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    _myButton.showsLargeContentViewer = YES;
    _myButton.largeContentTitle = @"button";
    _myButton.largeContentImage = @"hand.thumbsup";
    
    [_myButton addInteraction:[[UILargeContentViewerInteraction alloc] init]];
}

- (IBAction)tapButton:(UIButton *)sender {
    //Appropriate actions when the button is tapped.
}
@end
NS_ASSUME_NONNULL_END
</code></pre>
<pre><code class="swift">
class ButtonViewController: UIViewController {

    @IBOutlet weak var myButton: UIButton!
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        myButton.showsLargeContentViewer = true
        myButton.largeContentTitle = "button"
        myButton.largeContentImage = UIImage(systemName: "hand.thumbsup")
        myButton.addInteraction(UILargeContentViewerInteraction())
    }
    
    
    @IBAction func tapButton(_ sender: UIButton) {
        //Appropriate actions when the button is tapped.
    }
}
</code></pre>
<p><br>When <strong>the long press gesture is already implemented on the graphical element</strong>, it may be interesting to use the <code>gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:)</code> method that will be helpful to <a href="https://developer.apple.com/videos/play/wwdc2019/261/?time=636">set up the two gestures simutaneously</a>.</p>
</div>
<div class="tab-pane" id="largeContentViewer-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/uilargecontentvieweritem"><code>UILargeContentViewerItem</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uilargecontentviewerinteraction"><code>UILargeContentViewerInteraction</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiinteraction"><code>UIInteraction</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uigesturerecognizerdelegate/1624208-gesturerecognizer"><code>gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:)</code></a></li>
<li><a href="../wwdc/2019/261/">WWDC 2019 : Large Content Viewer</a></li>
</ul>
</div>
</div><br><br>
<h2 id="continuous-adjustable-values">Continuous adjustable values <a class="header-anchor" href="#continuous-adjustable-values" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#adjustable-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#adjustable-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#adjustable-Links" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="adjustable-Description"
     role="tabpanel">
<p>Graphics like <code>picker</code>, <code>stepper</code> or <code>slider</code> have the ability to continuously change the value they provide.<br>
<br><img alt="picker, stepper and slider screenshot" style="max-width: 700px; height: auto; " src="../../images/iOSdev/ValeursAjustables_1.png" /><br>
<br>It's hard to render what's happening when the changing isn't graphically or vocally notified.</p>
</div>
<div class="tab-pane" id="adjustable-Example" role="tabpanel">
<p>The following methodology to resolve this problem for blind people using VoiceOver may be the same for these three graphics, that's why only the <code>stepper</code> will be handled.<br>
<br><br>Creating a <code>stepper</code> with a <code>label</code> to display its value provides the following rendering :<br>
<br><img alt="stepper is vocalize like 3 differents objects" style="max-width: 900px; height: auto; " src="../../images/iOSdev/ValeursAjustables_2.png" /><br>
<br>The focus must change to :</p>
<ul>
<li>Get each element that increases or decreases the value.</li>
<li>Know the value provided by the <code>label</code>.</li>
</ul>
<p>Moreover, there is no real time notification dealing with the value changing.<br>
<br>Nothing is definitely blocking in use but these latest remarks lead to a new design for this example that used to be so simple.<br>
<br><br>The rationale behind is to be able to change the <code>stepper</code> value, to be informed of this modification and to know the new value thanks to a single and unique object.<br>
<br><strong>Group the <code>stepper</code>and the <code>label</code></strong> <em>(a StackView should do the job)</em> then put <strong><code>UIAccessibilityTraitAdjustable</code></strong> as a new trait for this new accessible group.<br>
<br>This <code>trait</code> is <strong>MANDATORY</strong> linked to the <code>accessibilityIncrement()</code> and <code>accessibilityDecrement()</code> methods that must be implemented to define the continous way of changing the value.<br>
<br><br>As a result, all the previous constraints are removed and a <code>hint</code> is natively provided by this <code>trait</code> to mention the proper way of using this object.<br>
<br><img alt="stepper is well vocalized" style="max-width: 1000px; height: auto; " src="../../images/iOSdev/ValeursAjustables_4.png" /></p>
<ul>
<li>To get this result, the container class {<code>stepper</code> + <code>label</code>} is first created to allow the delegation for the future value changing.</li>
</ul>
<pre><code class="objective-c">
-===== StepperWrapper.h =====-
NS_ASSUME_NONNULL_BEGIN
@class StepperWrapper;

@protocol AdjustableForAccessibilityDelegate &lt;NSObject&gt;
- (void)adjustableDecrementForView:(StepperWrapper *)view;
- (void)adjustableIncrementForView:(StepperWrapper *)view;
@end


@interface StepperWrapper : UIStackView
@property(nonatomic,weak) id &lt;AdjustableForAccessibilityDelegate&gt; delegate;
@end
NS_ASSUME_NONNULL_END
    
    
-===== StepperWrapper.m =====-
NS_ASSUME_NONNULL_BEGIN
@implementation StepperWrapper

- (instancetype)initWithCoder:(NSCoder *)coder {
    
    self = [super initWithCoder:coder];
    
    self.isAccessibilityElement = YES;
    self.accessibilityTraits = UIAccessibilityTraitAdjustable;
    
    return self;
}

- (void)accessibilityDecrement {
    if ([_delegate respondsToSelector:@selector(adjustableDecrementForView:)]) {
        [_delegate adjustableDecrementForView:self];
    }
}

- (void)accessibilityIncrement {
    if ([_delegate respondsToSelector:@selector(adjustableIncrementForView:)]) {
        [_delegate adjustableIncrementForView:self];
    }
}
</code></pre>
<pre><code class="swift">
protocol AdjustableForAccessibilityDelegate: class {
    func adjustableDecrementFor(_ view: StepperWrapper)
    func adjustableIncrementFor(_ view: StepperWrapper)
}


class StepperWrapper: UIStackView {

    weak var delegate: AdjustableForAccessibilityDelegate?
    
    override init(frame: CGRect) {
        super.init(frame: frame)
    }
    
    required init(coder: NSCoder) {
        super.init(coder: coder)
        
        isAccessibilityElement = true
        accessibilityTraits = .adjustable
    }
    
    override func accessibilityDecrement() {
        delegate?.adjustableDecrementFor(self)
    }
    
    override func accessibilityIncrement() {
        delegate?.adjustableIncrementFor(self)
    }
}
</code></pre>
<ul>
<li>Next, the two methods of the implemented protocol must be defined before updating and vocally presenting the new value in the ViewController.</li>
</ul>
<pre><code class="objective-c">
NS_ASSUME_NONNULL_BEGIN
@interface ContinuousAdjustableValues () &lt;AdjustableForAccessibilityDelegate&gt;
@property (weak, nonatomic) IBOutlet StepperWrapper * stepperStackViewAccess;
@property (weak, nonatomic) IBOutlet UIStepper * stepperAccess;
@property (weak, nonatomic) IBOutlet UILabel * stepperValueAccess;
@end


@implementation ContinuousAdjustableValues
- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    
    _stepperStackViewAccess.delegate = self;
    _stepperStackViewAccess.accessibilityLabel = @"increase or decrease the value";
    _stepperStackViewAccess.accessibilityValue = _stepperValueAccess.text;
}

- (void)adjustableDecrementForView:(StepperWrapper *)view {
    _stepperAccess.value  -= _stepperAccess.stepValue;
    [self updateStepperValue];
}

- (void)adjustableIncrementForView:(StepperWrapper *)view {
    _stepperAccess.value  += _stepperAccess.stepValue;
    [self updateStepperValue];
}

- (void) updateStepperValue {
    _stepperValueAccess.text = [NSString stringWithFormat:@"Value = %0.1f",_stepperAccess.value];
    _stepperStackViewAccess.accessibilityValue = _stepperValueAccess.text;
}
@end
NS_ASSUME_NONNULL_END
</code></pre>
<pre><code class="swift">
class ContinuousAdjustableValues: UIViewController, AdjustableForAccessibilityDelegate {
    
    @IBOutlet weak var stepperStackViewAccess: StepperWrapper!
    @IBOutlet weak var stepperAccess: UIStepper!
    @IBOutlet weak var stepperValueAccess: UILabel!
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        stepperStackViewAccess.delegate = self
        stepperStackViewAccess.accessibilityLabel = "increase or decrease the value"
        stepperStackViewAccess.accessibilityValue = stepperValueAccess.text
    }
    
    func adjustableDecrementFor(_ view: StepperWrapper) {
        stepperAccess.value -= stepperAccess.stepValue
        updateStepperValue()
    }
    
    func adjustableIncrementFor(_ view: StepperWrapper) {
        stepperAccess.value += stepperAccess.stepValue
        updateStepperValue()
    }
    
    private func updateStepperValue() {
        stepperValueAccess.text = "Value = \(stepperAccess.value)"
        stepperStackViewAccess.accessibilityValue = stepperValueAccess.text
    }
}
</code></pre>
</div>
<div class="tab-pane" id="adjustable-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitytraitadjustable"><code>UIAccessibilityTraitAdjustable</code></a></li>
</ul>
</div>
</div><br><br>
<h2 id="custom-actions">Custom actions <a class="header-anchor" href="#custom-actions" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#customActions-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#customActions-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#customActions-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="customActions-Description"
     role="tabpanel">
<p>Some basic gestures may become a real headache to be perfectly understood by VoiceOver in a fluent way for the user.<br>
<br>A convincing example is the iOS native mail that may suggest some actions as follows:<br>
<br><br></p>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#CustomActionsVoiceOver"
           role="tab" 
           aria-selected="true">VoiceOver</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#CustomActionsSwitchControl"
           role="tab" 
           aria-selected="false">Switch Control</a>
    </li>
</ul>
<div class="tab-content">
<div class="tab-pane show active"
     id="CustomActionsVoiceOver"
     role="tabpanel">
<img alt="flick left to display actions without VoiceOver" style="max-width: 900px; height: auto; " src="../../images/iOSdev/Actions_VoiceOver.png"/>
<br>This gesture cannot lead to the proper result with VoiceOver because a flick left will give rise to the selection of the next accessible element instead of suggesting actions as above.
<br><br>In this case, it would have been relevant to follow the pattern described in the `Example` sheet to get these actions if they weren't natively implemented.
</div>
<div class="tab-pane" 
     id="CustomActionsSwitchControl" 
     role="tabpanel">
<img alt="direct access to the mail actions with the switch control." style="max-width: 1000px; height: auto; " src="../../images/iOSdev/Actions_SwitchControl.png"/>
<br>All the available actions are present at the first screen so as to ease the user experience by reaching his goal as quick as possible.
<br>It's highly recommended to follow the pattern described in the `Example` sheet to get this purpose for a custom component.
</div></div>
</div>
<div class="tab-pane" id="customActions-Example" role="tabpanel">
<p>Whatever the VoiceOver or the Switch Control feature, the implementation to get the desired actions on a custom element is exactly the same: VoiceOver is the option to illustrate the following example.<br>
<br><br>A solution may consist of <strong>associating the selected element with an array of actions</strong> that will be automatically introduced to the user.<br>
<br><img alt="" style="max-width: 900px; height: auto; " src="../../images/iOSdev/Actions_2.png" /></p>
<pre><code class="objective-c">
@interface CustomActions ()
@property (weak, nonatomic) IBOutlet UILabel * persoElt;
@end


@implementation CustomActions
- (void)viewDidLoad {
    [super viewDidLoad];
    
    UIAccessibilityCustomAction * a11yMoreAction = [[UIAccessibilityCustomAction alloc]initWithName:@"more"
                                                                                             target:self
                                                                                           selector:@selector(moreAction)];
    UIAccessibilityCustomAction * a11yFlagAction = [[UIAccessibilityCustomAction alloc]initWithName:@"flag"
                                                                                             target:self
                                                                                           selector:@selector(flagAction)];
    UIAccessibilityCustomAction * a11yDeleteAction = [[UIAccessibilityCustomAction alloc]initWithName:@"delete"
                                                                                               target:self
                                                                                             selector:@selector(deleteAction)];
    
    _persoElt.accessibilityCustomActions = @[a11yMoreAction,
                                             a11yFlagAction,
                                             a11yDeleteAction];
}

- (BOOL)moreAction {
    //Code to be implemented for the appropriate action.
    return YES;
}

- (BOOL)flagAction {
    //Code to be implemented for the appropriate action.
    return YES;
}

- (BOOL)deleteAction {
    //Code to be implemented for the appropriate action.
    return YES;
}
@end
</code></pre>
<pre><code class="swift">
class CustomActions: UIViewController {
    
    @IBOutlet weak var persoElt: UILabel!
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        let a11yMoreAction = UIAccessibilityCustomAction(name: "more",
                                                         target: self,
                                                         selector: #selector(moreAction))
        
        let a11yFlagAction = UIAccessibilityCustomAction(name: "flag",
                                                         target: self,
                                                         selector: #selector(flagAction))
        
        // iOS 13 new syntax with a closure.
        let a11yDeleteAction = UIAccessibilityCustomAction(name: "delete",
                                                           actionHandler: { (customAction: UIAccessibilityCustomAction) -> Bool in
                                                              //Code to be implemented for the appropriate action.
                                                              return true
                                                           })
                                                           
        persoElt.accessibilityCustomActions = [a11yMoreAction,
                                               a11yFlagAction,
                                               a11yDeleteAction]
    }
    
    
    @objc func moreAction() -> Bool {
        //Code to be implemented for the appropriate action.
        return true
    }
    
    @objc func flagAction() -> Bool {
        //Code to be implemented for the appropriate action.
        return true
    }
}
</code></pre>
<p><br>The code above gives rise to the following result thanks to consecutive flicks on the selected accessible element :<br>
<br><img alt="flick up to vocalize suggesterd actions with VoiceOver activated" style="max-width: 900px; height: auto; " src="../../images/iOSdev/Actions_3.png" /><br>
<br>To get a visual information about this topic, take a look at the <strong>Accessibility Custom Actions</strong> video whose <a href="../wwdc/2019#AccessibilityCustomActions">detailed summary</a> is available at the WWDC section of this site.</p>
</div>
<div class="tab-pane" id="customActions-Links" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615150-accessibilitycustomactions"><code>accessibilityCustomActions</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitycustomaction"><code>UIAccessibilityCustomAction</code></a></li>
<li><a href="../wwdc/2017/215#CustomActions">WWDC 2017 : What's New in Accessibility</a></li>
<li><a href="../wwdc/2019#AccessibilityCustomActions">Accessibility Custom Actions</a></li>
</ul>
</div>
</div><br><br>
<h2 id="custom-rotor">Custom rotor <a class="header-anchor" href="#custom-rotor" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#rotor-Details" 
           role="tab" 
           aria-selected="true">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#rotor-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#rotor-Link" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="rotor-Details"
     role="tabpanel">
<p>Since iOS10, adding a new rotor option is possible thanks to the <strong>UIAccessibilityCustomRotor</strong> whose creation is based on 2 elements :</p>
<ul>
<li><strong>UIAccessibilityCustomRotorSearchPredicate</strong> : defines the logic according to the flick type on the screen.</li>
<li><strong>UIAccessibilityCustomRotorItemResult</strong> : ensued element from the logic above.</li>
</ul>
<img alt="" style="max-width: 500px; height: auto; " src="../../images/iOSdev/CustomRotor_1.png" />
</div>
<div class="tab-pane" id="rotor-Example" role="tabpanel">
<pre><code>To illustrate the programing side of this feature, the code snippet below counts and displays all the flicks up and down.
</code></pre>
<pre><code class="objective-c">
@interface CustomRotor ()
@property (weak, nonatomic) IBOutlet UILabel * rotorTitle;
@property (weak, nonatomic) IBOutlet UILabel * upLabel;
@property (weak, nonatomic) IBOutlet UILabel * downLabel;
@end


@implementation CustomRotor

static NSInteger flicksUp;
static NSInteger flicksDown;


+ (void)initialize {
    
    flicksUp = 0;
    flicksDown = 0;
}


- (void)viewDidLoad {
    [super viewDidLoad];
    
    UIAccessibilityCustomRotor * rotor = [self buildMyRotor:@"Rotor info"];
    self.accessibilityCustomRotors = @[rotor];
}


- (UIAccessibilityCustomRotor *)buildMyRotor:(NSString * _Nonnull)name{
    
    return [[UIAccessibilityCustomRotor alloc]initWithName:name
                                           itemSearchBlock:^UIAccessibilityCustomRotorItemResult * _Nullable(UIAccessibilityCustomRotorSearchPredicate * _Nonnull predicate) {
                                               
                                               if (predicate.searchDirection == UIAccessibilityCustomRotorDirectionNext) {
                                                   
                                                   flicksDown += 1;
                                                   self.downLabel.text = [NSString stringWithFormat:@"%ld",(long)flicksDown];
                                                   
                                               } else {
                                                   
                                                   flicksUp += 1;
                                                   self.upLabel.text = [NSString stringWithFormat:@"%ld",(long)flicksUp];
                                               }
                                               
                                               return [[UIAccessibilityCustomRotorItemResult alloc] initWithTargetElement:self.rotorTitle
                                                                                                              targetRange:nil];
                                           }];
}
@end
</code></pre>
<pre><code class="swift">
class CustomRotor: UIViewController {

    @IBOutlet weak var rotorTitle: UILabel!
    
    static var flicksUp = 0
    @IBOutlet weak var upLabel: UILabel!
    
    static var flicksDown = 0
    @IBOutlet weak var downLabel: UILabel!
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        let rotor = buildMyRotor("Rotor info")
        self.accessibilityCustomRotors = [rotor]
    }
    
    
    func buildMyRotor(_ name: String) -> UIAccessibilityCustomRotor {
        
        return  UIAccessibilityCustomRotor.init(name: name,
                                                itemSearch: { predicate -> UIAccessibilityCustomRotorItemResult? in
                                                    
                                                    if (predicate.searchDirection == UIAccessibilityCustomRotor.Direction.next) {
                                                        
                                                        CustomRotor.flicksDown += 1
                                                        self.downLabel.text = String(CustomRotor.flicksDown)
                                                        
                                                    } else {
                                                        
                                                        CustomRotor.flicksUp += 1
                                                        self.upLabel.text = String(CustomRotor.flicksUp)
                                                    }
                                                    
                                                    return UIAccessibilityCustomRotorItemResult.init(targetElement:self.rotorTitle,
                                                                                                     targetRange: nil)
        })
    }
}
</code></pre>
<p><br>The code above gives rise to the following illustrated steps :<br>
<br><img alt="changed display with a rotor option" style="max-width: 1100px; height: auto; " src="../../images/iOSdev/CustomRotor_2.png" /><br>
<br>The use of a custom rotor is definitely not a natural part of a mobile application, that's why its <strong>functioning</strong> and <strong>purpose</strong> must be <strong>fully explained</strong> to assist the user experience.<br>
<br><br>The main difference between a rotor option and a custom action or an adjustable element relies on the fact that it can be activated whatever the selected element.<br>
<br>However, if the selected element is adjustable or holds any custom actions, <strong>its actions will prevail over those of the rotor</strong>.<br>
<br><br>Such a feature must be implemented with <strong>caution</strong> and according to <strong>specific needs</strong> whose only purpose should be to <strong>improve and facilitate the user experience</strong>.</p>
</div>
<div class="tab-pane" id="rotor-Link" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitycustomrotor"><code>UIAccessibilityCustomRotor</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitycustomrotoritemresult"><code>UIAccessibilityCustomRotorItemResult</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitycustomrotorsearchpredicate"><code>UIAccessibilityCustomRotorSearchPredicate</code></a></li>
</ul>
</div>
</div><br><br>
<h2 id="accessibility-options">Accessibility options <a class="header-anchor" href="#accessibility-options" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#a11yOptions-States" 
           role="tab" 
           aria-selected="true">States</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#a11yOptions-Events" 
           role="tab" 
           aria-selected="false">Events</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#a11yOptions-Recap" 
           role="tab" 
           aria-selected="false">Recap</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#a11yOptions-Link" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="a11yOptions-States"
     role="tabpanel">
<p>On iOS, it is possible to check the accessibility options state.<br>
<br>Is VoiceOver activated? Is the audio-mono mode activated? Several methods that are part of the <code>UIKit</code> framework can help you to check with that.<br>
<br>The most useful method is <strong>UIAccessibilityIsVoiceOverRunning</strong> which allows to know whether VoiceOver is activated.<br>
<br><br>Some other methods are deeply explained in a <a href="../wwdc/2018/230" style="text-decoration: underline;">WWDC video</a> <em>(Deliver an exceptional accessibility experience)</em> whose content is perfectly detailed in the iOS WWDC section of this site.<br><br></p>
<pre><code class="objective-c">
    BOOL isVoiveOverRunning = (UIAccessibilityIsVoiceOverRunning() ? 1 : 0);
    BOOL isSwitchControlRunning = (UIAccessibilityIsSwitchControlRunning() ? 1 : 0);
    
    NSLog(@"VoiceOver is %d and SwitchControl is %d.", isVoiveOverRunning, isSwitchControlRunning);
</code></pre>
<pre><code class="swift">
    let isVoiceOverRunning = (UIAccessibility.isVoiceOverRunning ? 1 : 0)
    let isSwitchControlRunning = (UIAccessibility.isSwitchControlRunning ? 1 : 0)
        
    print("VoiceOver is \(isVoiceOverRunning) and SwichControl is \(isSwitchControlRunning).")
</code></pre>
</div>
<div class="tab-pane" id="a11yOptions-Events" role="tabpanel">
<p>iOS sends many accessibility events when accessibility options have changed.<br>
<br><br>For example, if VoiceOver is deactivated, the running applications will receive the <code>UIAccessibilityVoiceOverStatusDidChangeNotification</code> event.<br>
<br>This is very useful when used simultaneously with <code>UIAccessibilityIsVoiceOverRunning</code>.<br>
<br><br>Let's say the application behaves differently when VoiceOver is turned on.<br>
<br>What happens if VoiceOver is disabled ? This is exactly the use case when the system events can be used.<br>
<br>By listening to these events, it is possible to dynamically change how the application behaves.<br><br></p>
<p>In this example, a method is fired when VoiceOver or Switch Control status has changed.</p>
<pre><code class="objective-c">
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(methodToBeCalled:)
                                                 name:UIAccessibilitySwitchControlStatusDidChangeNotification
                                               object:nil];
    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(methodToBeCalled:)
                                                 name:UIAccessibilityVoiceOverStatusDidChangeNotification
                                               object:nil];
}

- (void)methodToBeCalled:(NSNotification *)notification {
    
    NSArray * checkStatus = @[@"NOK", @"OK"];
    
    NSLog(@"SWITCH CONTROL is %@ and VOICE OVER is %@",
          checkStatus[UIAccessibilityIsSwitchControlRunning()],
          checkStatus[UIAccessibilityIsVoiceOverRunning()]);
}
</code></pre>
<pre><code class="swift">
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(methodToBeCalled(notification:)),
                                               name: UIAccessibility.switchControlStatusDidChangeNotification,
                                               object: nil)
        
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(methodToBeCalled(notification:)),
                                               name: UIAccessibility.voiceOverStatusDidChangeNotification,
                                               object: nil)
    }
    
    @objc private func methodToBeCalled(notification: Notification) {

        let switchControlStatus = (UIAccessibility.isSwitchControlRunning ? "OK" : "NOK")
        let voiceOverStatus = (UIAccessibility.isVoiceOverRunning ? "OK" : "NOK")
        
        print("SWITCH CONTROL is \(switchControlStatus) and VOICE OVER is \(voiceOverStatus).")
    }
</code></pre>
</div>
<div class="tab-pane" id="a11yOptions-Recap" role="tabpanel">
<p>All accessibility <a href="https://developer.apple.com/documentation/uikit/accessibility/notification_names?language=objc" style="text-decoration: underline;">events</a> and <a href="https://developer.apple.com/documentation/uikit/accessibility?language=objc" style="text-decoration: underline;">options</a> are available on the official documentation from Apple.<br>
<br><img alt="" style="max-width: 1100px; height: auto; " src="../../images/iOSdev/OptionsA11Y.png" /></p>
</div>
<div class="tab-pane" id="a11yOptions-Link" role="tabpanel">
<ul>
<li><a href="./../design#accessibility-options">Accessibility options</a> <em>(iOS conception)</em></li>
</ul>
</div>
</div><br><br>
<h2 id="navigation-bar">Navigation bar <a class="header-anchor" href="#navigation-bar" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#navBar-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#navBar-LeftBarItem" 
           role="tab" 
           aria-selected="false">LeftBarItem</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#navBar-Title" 
           role="tab" 
           aria-selected="false">Title</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#navBar-RightBarItem" 
           role="tab" 
           aria-selected="false">RightBarItem</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#navBar-ReadingOrder" 
           role="tab" 
           aria-selected="false">Reading order</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#navBar-Link" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="navBar-Description"
     role="tabpanel">
<p>Using a navigation bar is a common practice that can be divided into three main parts:<br>
<br><br><img alt="" style="max-width: 500px; height: auto; " src="../../images/iOSdev/NavigationBar_1.png" /></p>
<ul>
<li><strong>LeftBarItem</strong> : usually includes only a single element to get back to the previous screen.</li>
<li><strong>Title</strong> : often presented as a simple text that may be build with StackViews in the most complex use cases.</li>
<li><strong>RightBarItem</strong> : area  that might contains many different icons <em>(account, authentication, validation...)</em>.</li>
</ul>
<p>Using the standard components with few navigation bar customizations is a good way to give rise to the best VoiceOver result with minimal effort.<br>
<br><br>Unfortunately, some project constraints may prevent such a practice: specific examples are then provided hereunder so as to ease some delicate implementations that might include the reading order of items comprising even those of the navigation bar.</p>
</div>
<div class="tab-pane" id="navBar-LeftBarItem" role="tabpanel">
<p>Once the navigation bar loaded, a new <code>label</code> must be provided so as to amend only the VoiceOver reading out without modifying the appearance of the left bar item.</p>
<pre><code class="objective-c">
    self.navigationController.navigationBar.backItem.accessibilityLabel = @"new label for the back button";
</code></pre>
<pre><code class="swift">
    navigationController?.navigationBar.backItem?.accessibilityLabel = "new label for the back button"
</code></pre>
<p><br>The customization of this element often consists in <strong>displaying a single disclosure indicator with no text</strong>.<br>
<br><img alt="" style="max-width: 400px; height: auto; " src="../../images/iOSdev/NavigationBar_2.png" /><br>
<br>The two possible achievements that are detailed in the following examples are based on the standard component replacement by a customized <strong>UIBarButtonItem</strong> with a simple <strong>image as an incoming parameter</strong> for the disclosure indicator:</p>
<pre><code class="objective-c">
    UIBarButtonItem &#42; _a11yLeftBarButton;
    
    _a11yLeftBarButton = [[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@"imgInfo"]
                                                         style:UIBarButtonItemStyleDone
                                                        target:self
                                                        action:@selector(goBackToThePreviousView:)];
    
    _a11yLeftBarButton.accessibilityLabel = @"previous screen";
    self.navigationItem.leftBarButtonItem = _a11yLeftBarButton;
</code></pre>
<pre><code class="swift">
    var a11yLeftBarButton: UIBarButtonItem?
    
    a11yLeftBarButton = UIBarButtonItem(image: UIImage(named: "imgInfo"),
                                        style: .done,
                                        target: self,
                                        action: #selector(goBackToThePreviousView(info:)))

    a11yLeftBarButton!.accessibilityLabel = "previous screen"
    navigationItem.leftBarButtonItem = a11yLeftBarButton
</code></pre>
<p><br>... or on a <strong>UIView</strong> with an added gesture recognizer to define the action of this element: it's a little bit longer than the previous one but it has the advantage of <strong>providing a frame</strong> whose interest will be enlighted if the reading order of the page items will include those of the navigation bar for instance.</p>
<pre><code class="objective-c">
    var a11yLeftBarButton: UIBarButtonItem?
    
    UIImage &#42; img = [UIImage imageNamed:@"imgInfo"];
    UIImageView &#42; imgView = [[UIImageView alloc]initWithImage:img];
    _a11yLeftBarButton = [[UIBarButtonItem alloc]initWithCustomView:imgView];
    
    UITapGestureRecognizer &#42; tap = [[UITapGestureRecognizer alloc]initWithTarget:self
                                                                          action:@selector(goBackToThePreviousView:)];
    [_a11yLeftBarButton.customView addGestureRecognizer:tap];
    
    _a11yLeftBarButton.isAccessibilityElement = YES;
    _a11yLeftBarButton.accessibilityTraits = UIAccessibilityTraitButton;
    _a11yLeftBarButton.accessibilityLabel = @"previous screen";
    
    self.navigationItem.leftBarButtonItem = _a11yLeftBarButton;
</code></pre>
<pre><code class="swift">
    var a11yLeftBarButton: UIBarButtonItem?
    
    let a11yLeftBarButtonImage = UIImage(named: "imgInfo")
    a11yLeftBarButton = UIBarButtonItem(customView: UIImageView(image: a11yLeftBarButtonImage))
        
    let tap = UITapGestureRecognizer(target: self,
                                     action: #selector(goBackToThePreviousView(info:)))
    a11yLeftBarButton?.customView?.addGestureRecognizer(tap)
        
    a11yLeftBarButton?.isAccessibilityElement = true
    a11yLeftBarButton?.accessibilityTraits = .button
    a11yLeftBarButton?.accessibilityLabel = "previous screen"
        
    navigationItem.leftBarButtonItem = a11yLeftBarButton
</code></pre>
<p><br>Then, the chosen implementation will depend on the purpose of the new created element.</p>
</div>
<div class="tab-pane" id="navBar-Title" role="tabpanel">
<p>In order to have a quick access to the accessibility properties of a navigation bar title item, it's recommended to <strong>implement its content in UIView form</strong>:</p>
<pre><code class="objective-c">
    UILabel &#42; a11yTitleLabel = [[UILabel alloc]init];
    a11yTitleLabel.text = @"TITLE";
    [a11yTitleLabel sizeToFit];
    
    self.navigationItem.titleView = a11yTitleLabel;
    self.navigationItem.titleView.accessibilityLabel = @"writing and reading out are different";
</code></pre>
<pre><code class="swift">
    let a11yTitleLabel = UILabel()
    a11yTitleLabel.text = "TITLE"
    a11yTitleLabel.sizeToFit()

    navigationItem.titleView = a11yTitleLabel
    navigationItem.titleView?.accessibilityLabel = "writing and reading out are different"
</code></pre>
</div>
<div class="tab-pane" id="navBar-RightBarItem" role="tabpanel">
<p><br><img alt="" style="max-width: 400px; height: auto; " src="../../images/iOSdev/NavigationBar_3.png" /><br>
<br><strong>Using UIView is recommended</strong> when new elements are created in the right part of the navigation bar so as to ease some VoiceOver future implementations.</p>
<pre><code class="objective-c">
    UIBarButtonItem &#42; _a11yRightBarButton;

    UILabel &#42; a11y = [[UILabel alloc]init];
    a11y.text = @"OK";
    [a11y sizeToFit];
    [a11y setUserInteractionEnabled:YES]; //Mandatory to use the 'tap gesture'.
    
    _a11yRightBarButton = [[UIBarButtonItem alloc]initWithCustomView:a11y];
    
    UITapGestureRecognizer &#42; tap = [[UITapGestureRecognizer alloc]initWithTarget:self 
                                                                          action:@selector(validateActions:)];
    [_a11yRightBarButton.customView addGestureRecognizer:tap];
    
    _a11yRightBarButton.isAccessibilityElement = YES;
    _a11yRightBarButton.accessibilityTraits = UIAccessibilityTraitButton;
    _a11yRightBarButton.accessibilityLabel = @"validate your actions";
    
    self.navigationItem.rightBarButtonItem = _a11yRightBarButton;
</code></pre>
<pre><code class="swift">
    var a11yRightBarButton: UIBarButtonItem?

    let a11y = UILabel()
    a11y.text = "OK"
    a11y.sizeToFit()
    a11y.isUserInteractionEnabled = true //Mandatory to use the 'tap gesture'.

    a11yRightBarButton = UIBarButtonItem(customView: a11y)
        
    let tap = UITapGestureRecognizer(target: self,
                                     action: #selector(validateActions(info:)))
    a11yRightBarButton?.customView?.addGestureRecognizer(tap)
        
    a11yRightBarButton?.isAccessibilityElement = true
    a11yRightBarButton?.accessibilityTraits = .button
    a11yRightBarButton?.accessibilityLabel = "validate your actions"
        
    navigationItem.rightBarButtonItem = a11yRightBarButton
</code></pre>
</div>
<div class="tab-pane" id="navBar-ReadingOrder" role="tabpanel">
<p>Usually, we don't need to change the VoiceOver reading order for the navigation bar items but it's sometimes necessary ⟹ tutorial page whose <code>RightBarItem</code> triggers the display of the next page for instance.<br>
<br><br>As an example, let's assume that the <code>RightBarItem</code> must be the last focused element thanks to one-finger left flicks in order to illustrate a reading order modification that involves the navigation bar items.<br>
<br><br>The proposed page will be composed of the following elements:</p>
<ul>
  <li>A navigation bar with a disclosure indicator *(LeftBarItem)*, a title and a 'OK' button *(RightBarItem)*.</li>
  <li>Five not consecutive labels.</li>
  <li>An 'ACTION' button that is horizontally and vertically centered.</li>
</ul>
<img alt="" style="max-width: 200px; height: auto; " src="../../images/iOSdev/NavigationBar_4.png" />
<p><br>The rationale behind this presentation is to follow this order: LeftBarItem, title, Label1, Label2, Label3, 'ACTION' button, Label4, Label5 and RightBarItem.<br>
<br><br>First of all, the navigation bar items are customized thanks to the code examples provided in the other sheets of this section.</p>
<pre><code class="objective-c">
@interface NavigationBarReadingOrder() {
    UIBarButtonItem &#42; _a11yLeftBarButton;
    UIView &#42; _a11yBarTitle;
    UIBarButtonItem &#42; _a11yRightBarButton;
}
@end


@implementation NavigationBarReadingOrder

- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self setBackItem];
    [self setTitle];
    [self setNextPageBarButton];
}


- (void)setBackItem {
    
    UIImage &#42; img = [UIImage imageNamed:@"infoImg"];
    UIImageView &#42; imgView = [[UIImageView alloc]initWithImage:img];
    _a11yLeftBarButton = [[UIBarButtonItem alloc]initWithCustomView:imgView];
    
    UITapGestureRecognizer &#42; tap = [[UITapGestureRecognizer alloc]initWithTarget:self
                                                                          action:@selector(goBackToThePreviousView:)];
    [_a11yLeftBarButton.customView addGestureRecognizer:tap];
    
    self.navigationItem.leftBarButtonItem = _a11yLeftBarButton;
}


- (void)setTitle {
    
    UILabel &#42; a11yTitleLabel = [[UILabel alloc]init];
    a11yTitleLabel.text = @"TITLE";
    [a11yTitleLabel sizeToFit];
    
    self.navigationItem.titleView = a11yTitleLabel;
    _a11yBarTitle = self.navigationItem.titleView;
}


- (void)setNextPageBarButton {
    
    UILabel &#42; a11y = [[UILabel alloc]init];
    a11y.text = @"OK";
    [a11y sizeToFit];
    [a11y setUserInteractionEnabled:YES];
    
    _a11yRightBarButton = [[UIBarButtonItem alloc]initWithCustomView:a11y];
    
    UITapGestureRecognizer &#42; tap = [[UITapGestureRecognizer alloc]initWithTarget:self
                                                                          action:@selector(validateActions:)];
    [_a11yRightBarButton.customView addGestureRecognizer:tap];
    
    self.navigationItem.rightBarButtonItem = _a11yRightBarButton;
}
@end
</code></pre>
<pre><code class="swift">
class OrderViewController: UIViewController {

    var a11yLeftBarButton: UIBarButtonItem?
    var a11yBarTitle: UIView?
    var a11yRightBarButton: UIBarButtonItem?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        setBackItem()
        setTitle()
        setNextPageBarButton()
    }
    
    private func setBackItem() {
        let a11yLeftBarButtonImage = UIImage(named: "infoImg")
        a11yLeftBarButton = UIBarButtonItem(customView: UIImageView(image: a11yLeftBarButtonImage))

        let tap = UITapGestureRecognizer(target: self,
                                         action: #selector(goBackToThePreviousView(info:)))
        a11yLeftBarButton?.customView?.addGestureRecognizer(tap)

        navigationItem.leftBarButtonItem = a11yLeftBarButton
    }
    
    private func setTitle() {
        
        let a11yTitleLabel = UILabel()
        a11yTitleLabel.text = "TITLE"
        a11yTitleLabel.sizeToFit()

        navigationItem.titleView = a11yTitleLabel
        a11yBarTitle = navigationItem.titleView
    }
    
    private func setNextPageBarButton() {
    
        let a11y = UILabel()
        a11y.text = "OK"
        a11y.sizeToFit()
        a11y.isUserInteractionEnabled = true

        a11yRightBarButton = UIBarButtonItem(customView: a11y)
        
        let tap = UITapGestureRecognizer(target: self,
                                         action: #selector(goToTheNextPage(info:)))
        a11yRightBarButton?.customView?.addGestureRecognizer(tap)
        
        navigationItem.rightBarButtonItem = a11yRightBarButton
    }
}
</code></pre>
<p><br>Next, we <strong>create accessible elements</strong> for the navigation bar and we <strong>define the VoiceOver reading order</strong> for the entire page thanks to its <code>accessibilityElements</code> array.<br>
<br>The entire page and the navigation bar are two different containers that lead to <strong>hiding to VoiceOver the navigation bar native items</strong> and to transfer them to the page view with the focus appropriate coordinates.</p>
<pre><code class="objective-c">
@interface NavigationBarReadingOrder() {
    UIBarButtonItem &#42; _a11yLeftBarButton;
    UIView &#42; _a11yBarTitle;
    UIBarButtonItem &#42; _a11yRightBarButton;
}

@property (weak, nonatomic) IBOutlet UILabel &#42; a11yLabel1;
@property (weak, nonatomic) IBOutlet UILabel &#42; a11yLabel2;
@property (weak, nonatomic) IBOutlet UILabel &#42; a11yLabel3;
@property (weak, nonatomic) IBOutlet UILabel &#42; a11yLabel4;
@property (weak, nonatomic) IBOutlet UILabel &#42; a11yLabel5;
@property (weak, nonatomic) IBOutlet UIButton &#42; a11yCentralButton;

@end


@implementation NavigationBarReadingOrder

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    
    [self createA11yElts];
    self.navigationController.navigationBar.accessibilityElementsHidden = YES;
}


- (void)createA11yElts {
    
    UIView &#42; navBarView = [[[_a11yBarTitle superview] superview] superview];
    
    UIView &#42; leftButtonView = [_a11yLeftBarButton valueForKey:@"view"];
    UIAccessibilityElement * a11yLBB = [[UIAccessibilityElement alloc] initWithAccessibilityContainer:self.view];
    a11yLBB.accessibilityFrameInContainerSpace = [navBarView convertRect:[[leftButtonView superview] superview].frame toView:self.view];
    a11yLBB.accessibilityLabel = @"previous screen";
    a11yLBB.accessibilityTraits = UIAccessibilityTraitButton;
    
    UIAccessibilityElement &#42; a11yTBV = [[UIAccessibilityElement alloc] initWithAccessibilityContainer:self.view];
    a11yTBV.accessibilityFrameInContainerSpace = [navBarView convertRect:[self.navigationItem.titleView superview].frame toView:self.view];
    a11yTBV.accessibilityLabel = @"writing and reading out are different";
    a11yTBV.accessibilityTraits = UIAccessibilityTraitHeader;

    UIView &#42; rightButtonView = [_a11yRightBarButton valueForKey:@"view"];
    UIAccessibilityElement &#42; a11yRBB = [[UIAccessibilityElement alloc] initWithAccessibilityContainer:self.view];
    a11yRBB.accessibilityFrameInContainerSpace = [navBarView convertRect:[[rightButtonView superview] superview].frame toView:self.view];
    a11yRBB.accessibilityLabel = @"next screen";
    a11yRBB.accessibilityTraits = UIAccessibilityTraitButton;
    
    self.view.accessibilityElements = @[a11yLBB,
                                        a11yTBV,
                                        _a11yLabel1,
                                        _a11yLabel2,
                                        _a11yLabel3,
                                        _a11yCentralButton,
                                        _a11yLabel4,
                                        _a11yLabel5,
                                        a11yRBB];
}
@end

</code></pre>
<pre><code class="swift">
@IBOutlet weak var a11yLabel1: UILabel!
@IBOutlet weak var a11yLabel2: UILabel!
@IBOutlet weak var a11yLabel3: UILabel!
@IBOutlet weak var a11yLabel4: UILabel!
@IBOutlet weak var a11yLabel5: UILabel!
@IBOutlet weak var a11yCentralButton: UIButton!

override func viewDidAppear(&#95; animated: Bool) {
    super.viewDidAppear(animated)
        
    createA11yElts()
    navigationController?.navigationBar.accessibilityElementsHidden = true
}
    
private func createA11yElts() {
        
    let navBarView = a11yBarTitle?.superview?.superview?.superview

    let leftButtonView = a11yLeftBarButton?.value(forKey: "view") as? UIView
    let a11yLBB = UIAccessibilityElement(accessibilityContainer: self.view!)
    a11yLBB.accessibilityFrameInContainerSpace = navBarView!.convert((leftButtonView?.superview?.superview!.frame)!,to:self.view)
    a11yLBB.accessibilityLabel = "previous screen"
    a11yLBB.accessibilityTraits = .button

    let a11yTBV = UIAccessibilityElement(accessibilityContainer: self.view!)
    a11yTBV.accessibilityFrameInContainerSpace = navBarView!.convert((navigationItem.titleView?.superview!.frame)!,to:self.view)
    a11yTBV.accessibilityLabel = "writing and reading out are different"
    a11yTBV.accessibilityTraits = .header

    let rightButtonView = a11yRightBarButton?.value(forKey: "view") as? UIView
    let a11yRBB = UIAccessibilityElement(accessibilityContainer: self.view!)
    a11yRBB.accessibilityFrameInContainerSpace = navBarView!.convert((rightButtonView?.superview?.superview!.frame)!,to:self.view)
    a11yRBB.accessibilityLabel = "next screen"
    a11yRBB.accessibilityTraits = .button

    self.view.accessibilityElements = [a11yLBB,
                                       a11yTBV,
                                       a11yLabel1!,
                                       a11yLabel2!,
                                       a11yLabel3!,
                                       a11yCentralButton!,
                                       a11yLabel4!,
                                       a11yLabel5!,
                                       a11yRBB]
}
</code></pre>
<p><br>The result corresponds to the desired reading order using successive one-finger flicks to select the different accessible elements.<br>
<br><img alt="" style="max-width: 1000px; height: auto; " src="../../images/iOSdev/NavigationBar_5.png" /><br>
<br><img alt="" style="max-width: 1000px; height: auto; " src="../../images/iOSdev/NavigationBar_6.png" /></p>
</div>
<div class="tab-pane" id="navBar-Link" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/uinavigationbar">UINavigationBar</a></li>
</ul>
</div>
</div>
<br><br>
<h2 id="speech-synthesis">Speech synthesis <a class="header-anchor" href="#speech-synthesis" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#speechSyn-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#speechSyn-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#speechSyn-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#speechSyn-Phonemes" 
           role="tab" 
           aria-selected="false">Phonemes</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#speechSyn-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="speechSyn-Description"
     role="tabpanel">
<p>Many <a href="../wwdc/2018/236#Uses">use cases</a> are good candidates to use the speech synthesis and they aren't necessary all part of accessibility.<br>
<br><br>However, in that perspective, it's important to note that this <strong>feature doesn't replace VoiceOver</strong> but could be a good complement to the screen reader implementation <em>(the speech overlaps the screen reader voice)</em>.</p>
</div>
<div class="tab-pane" id="speechSyn-Details" role="tabpanel">
<p>Few elements are mandatory to create a speech synthesis on the fly:</p>
<ul>
  <li>**The text**: `AVSpeechUtterance` instance with a `voice` property that's `AVSpeechSynthesisVoice` typed.</li>
  <li>**The synthesizer**: `AVSpeechSynthesizer` instance that handles the incoming text with an events control thanks to the `AVSpeechSynthesizerDelegate` protocol.</li>
</ul>
<img alt="" style="max-width: 800px; height: auto; " src="../../images/iOSdev/SpeechSynthesizer.png" />
</div>
<div class="tab-pane" id="speechSyn-Example" role="tabpanel">
<p>To be sure that a bunch of <code>AVSpeechUtterance</code> instances is entirely vocalized, it's <a href="../wwdc/2018/236#Basics">essential</a> to retain the <code>AVSpeechSynthesizer</code> instance until the speech is done.<br>
<br><br>The following example will define the speech rate and the voice pitch/volume for each utterance while:</p>
<ul>
  <li>Highlighting the vocalized word thanks to the `AVSpeechSynthesizerDelegate` protocol.</li>
  <li>Pausing and resuming from where the speech stopped thanks to some `AVSpeechSynthesizer` instance methods.</li>
</ul>
<pre><code class="objective-c">
@interface SpeechSynthesis()  <AVSpeechSynthesizerDelegate> {

    NSMutableArray * playerQueue;
    AVSpeechSynthesizer * synthesizer;
    __weak IBOutlet UILabel * textLabel;
}
@end

NS_ASSUME_NONNULL_BEGIN
@implementation SpeechSynthesis

- (void)viewDidLoad {
    [super viewDidLoad];
    
    playerQueue = [[NSMutableArray alloc] init];
    synthesizer = [[AVSpeechSynthesizer alloc] init];
}

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    
    for (int i = 1 ; i < 11 ; i++) {
     
        NSString * stringNbPrefix = @"Sentence number ";
        NSString * stringNbSuffix = @" of the speech synthesizer.";
        NSString * stringNb = [NSString stringWithFormat:@"%@%i%@", stringNbPrefix, i, stringNbSuffix];
        
        AVSpeechUtterance * utterance = [[AVSpeechUtterance alloc] initWithString:stringNb];
        utterance.rate = AVSpeechUtteranceDefaultSpeechRate;
        utterance.pitchMultiplier = 1.0;
        utterance.volume = 1.0;
        
        [playerQueue addObject:utterance];
    }
    
    synthesizer.delegate = self;
    
    for (AVSpeechUtterance * utterance in playerQueue) {
        [synthesizer speakUtterance:utterance];
    }
}

//AVSpeechSynthesizerDelegate protocol method to highlight the vocalized word.
- (void)speechSynthesizer:(AVSpeechSynthesizer *)synthesizer
willSpeakRangeOfSpeechString:(NSRange)characterRange
                utterance:(AVSpeechUtterance *)utterance {
    
    NSMutableAttributedString * attributedString = [[NSMutableAttributedString alloc] initWithString:utterance.speechString];
    
    [attributedString addAttribute:NSFontAttributeName
                             value:[UIFont systemFontOfSize:19.0]
                             range:characterRange];
    
    NSAttributedString * subString = [attributedString attributedSubstringFromRange:characterRange];
    textLabel.attributedText = attributedString;
    
    NSString * output = [NSString stringWithFormat:@"%@%@", @"word : ", subString.string];
    NSLog(@"%@", output);
}

- (IBAction)pauseButton:(UIButton *)sender {
    
    if (synthesizer.isSpeaking == TRUE) {
        if ([synthesizer pauseSpeakingAtBoundary:AVSpeechBoundaryImmediate] == TRUE) {
            NSLog(@"PAUSE");
        } else {
            NSLog(@"P.R.O.B.L.E.M. when pausing.");
        }
    }
}

- (IBAction)resumeButton:(UIButton *)sender {
    
    if (synthesizer.isPaused == TRUE) {
        if ([synthesizer continueSpeaking] == TRUE) {
            NSLog(@"RESUME");
        } else {
            NSLog(@"P.R.O.B.L.E.M. when resuming.");
        }
    }
}
@end
</code></pre>
<pre><code class="swift">
class SpeechSynthesis: UIViewController, AVSpeechSynthesizerDelegate {
    
    @IBOutlet weak var textLabel: UILabel!
    
    var synthesizer = AVSpeechSynthesizer()
    var playQueue = [AVSpeechUtterance]()
    
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        for i in 1...10 {
            
            let stringNb = "Sentence number " + String(i) + " of the speech synthesizer."
            
            let utterance = AVSpeechUtterance(string: stringNb)
            utterance.rate = AVSpeechUtteranceDefaultSpeechRate
            utterance.pitchMultiplier = 1.0
            utterance.volume = 1.0
            
            playQueue.append(utterance)
        }

        synthesizer.delegate = self

        for utterance in playQueue {
            synthesizer.speak(utterance)
        }
    }
    
    //AVSpeechSynthesizerDelegate protocol method to highlight the vocalized word.
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer,
                           willSpeakRangeOfSpeechString characterRange: NSRange,
                           utterance: AVSpeechUtterance) {

        let attributedString = NSMutableAttributedString(string: utterance.speechString)
        attributedString.addAttribute(.font,
                                      value: UIFont.boldSystemFont(ofSize: 19),
                                      range: characterRange)

        textLabel.attributedText = attributedString

        let subString = attributedString.attributedSubstring(from: characterRange)
        print("word : \(subString.string)")
    }
    
    
    @IBAction func pauseAction(_ sender: UIButton) {
    
        if (synthesizer.isSpeaking == true) {
            if (synthesizer.pauseSpeaking(at: .immediate) == true) {
                print("PAUSE")
            } else {
                print("P.R.O.B.L.E.M. when pausing.")
            }
        }
    }
    
    
    @IBAction func resumeAction(_ sender: UIButton) {
     
        if (synthesizer.isPaused == true) {
            if (synthesizer.continueSpeaking() == true) {
                print("RESUME")
            } else {
                print("P.R.O.B.L.E.M. when resuming.")
            }
        }
    }
}
</code></pre>
</div>
<div class="tab-pane" id="speechSyn-Phonemes" role="tabpanel">
<p>When a particular spelling is intended, phonetics is highly recommended to get the desired purpose.</p>
<pre><code class="objective-c">
    NSMutableAttributedString &#42; attrStr = [[NSMutableAttributedString alloc] initWithString:@"blablabla" 
                                                                             attributes:@{AVSpeechSynthesisIPANotationAttribute:@"ˈma͡ɪ.ˈa͡ɪ.ˈfʌ.ˈniz.ˈgɻe͡ɪt"}];
    
    AVSpeechUtterance &#42; utterance = [[AVSpeechUtterance alloc] initWithAttributedString:attrStr];
    
    AVSpeechSynthesizer &#42; synthesizer = [[AVSpeechSynthesizer alloc] init];
    [synthesizer speakUtterance:utterance];
</code></pre>
<pre><code class="swift">
        let pronunciationKey = NSAttributedString.Key(rawValue: AVSpeechSynthesisIPANotationAttribute)
        
        let attrStr = NSMutableAttributedString(string: "blablabla",
                                                attributes: [pronunciationKey: "ˈma͡ɪ.ˈa͡ɪ.ˈfʌ.ˈniz.ˈgɻe͡ɪt"])

        let utterance = AVSpeechUtterance(attributedString: attrStr)

        let synthesizer = AVSpeechSynthesizer()
        synthesizer.speak(utterance)
</code></pre>
<p><br>Generating phonetics may be done in the device settings.</p>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#Phonemes-iOS13"
           role="tab" 
           aria-selected="true">iOS 13</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#Phonemes-iOS12"
           role="tab" 
           aria-selected="false">iOS 12</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="Phonemes-iOS13"
     role="tabpanel">
<img alt="" style="max-width: 850px; height: auto; " src="../../images/iOSdev/SpeechSynthesizerEx_iOS13_1.png" />
</div>
<div class="tab-pane" 
     id="Phonemes-iOS12" 
     role="tabpanel">
<img alt="" style="max-width: 1100px; height: auto; " src="../../images/iOSdev/SpeechSynthesizerEx_1.png" />
</div></div>
<p><br>Once the menu <code>Pronunciations</code> is reached...<br>
<br><img alt="" style="max-width: 1100px; height: auto; " src="../../images/iOSdev/SpeechSynthesizerEx_2.png" /><br><br></p>
<ol>
  <li>Select the '**+**' icon to add a new phonetic element.</li>
  <li>Name this new element in order to quickly find it later on.</li>
  <li>Tap the **microphone** icon.</li>
  <li>Vocalize an entire sentence or a single word.</li>
  <li>Listen to the different system proposals.</li>
  <li>Validate your choice with the '**OK**' button or cancel to start over.</li>
  <li>Tap the back button to confirm the new created phonetic element.</li>
  <li>Find all the generated elements in the `Pronunciations` page.</li>
</ol>
<img alt="" style="max-width: 1100px; height: auto; " src="../../images/iOSdev/SpeechSynthesizerEx_3.png"/>
<br>To get the phonetic expression inside the code, pass it through the mobile `Notes` application to be synchronized with the iCloud one from which a copy-paste becomes easy as a pie.
</div>
<div class="tab-pane" id="speechSyn-Links" role="tabpanel">
<ul>
  <li>[AVSpeechSynthesisVoice](https://developer.apple.com/documentation/avfoundation/avspeechsynthesisvoice)</li>
  <li>[AVSpeechSynthesizer](https://developer.apple.com/documentation/avfoundation/avspeechsynthesizer)</li>
  <li>[AVSpeechSynthesizerDelegate](https://developer.apple.com/documentation/avfoundation/avspeechsynthesizerdelegate)</li>
  <li>[AVSpeechUtterance](https://developer.apple.com/documentation/avfoundation/avspeechutterance) </li>
  <li>[WWDC 2018 : Making iOS talk with AVSpeechSynthesizer](../wwdc/2018/236) </li>
</ul>
</div>
</div>
<p>All the speech synthesizer functionalities are introduced in a <a href="../wwdc/2018/236">WWDC video</a> <em>(Making iOS talk with AVSpeechSynthesizer)</em> that's perfectly summarized in the WWDC section of this site.<br>
<br><br></p>
<h2 id="switch-control">Switch Control <a class="header-anchor" href="#switch-control" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#switchCtrl-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#switchCtrl-Custom" 
           role="tab" 
           aria-selected="false">Item mode customization</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#switchCtrl-Link" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="switchCtrl-Description"
     role="tabpanel">
<p>The accessibility Switch Control feature revolves around the point mode and the item mode.<br>
<br><img alt="accessibility switch control screenshots" style="max-width: 700px; height: auto; " src="../../images/iOSdev/SwitchControl.png" /><br>
<br>The element selection using the item mode works fine when the user interface isn't too complicated and uses native elements.<br>
<br>However, this mode may not be helpful according to the rationale behind some specific use cases and then needs to be customized.</p>
</div>
<div class="tab-pane" id="switchCtrl-Custom" role="tabpanel">
<p>The Xcode InterfaceBuilder shows the structure used for the example hereunder :<br>
<br><img alt="xcode screenshot" style="max-width: 700px; height: auto; " src="../../images/iOSdev/SwitchControlIB.png" /><br>
<br>The following steps represent the customization :</p>
<ul>
<li>Creation of 2 groups {Test_1 + Test_2 ; Btn 5 + Btn 6} that must be selectable in the item mode.</li>
<li>Within the other elements, only Btn 1 et Btn 2 must be separately accessible.</li>
</ul>
<pre><code class="objective-c">
@interface ViewController2 ()

@property (weak, nonatomic) IBOutlet UIStackView * btnsParentView;
@property (weak, nonatomic) IBOutlet UIButton * btn1;
@property (weak, nonatomic) IBOutlet UIButton * btn2;
@property (weak, nonatomic) IBOutlet UIButton * btn5;
@property (weak, nonatomic) IBOutlet UIButton * btn6;

@end


@implementation ViewController2
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    
    //Creation of the first group 'testWrap' COMBINING the 'Test_1' and 'Test_2' buttons.
    UIButton * testOneButton = [self.view viewWithTag:1];
    UIButton * testTwoButton = [self.view viewWithTag:2];
    CGRect testWrapFrame = CGRectUnion(testOneButton.frame, testTwoButton.frame);
    
    UIAccessibilityElement * testWrap = [[UIAccessibilityElement alloc]initWithAccessibilityContainer:self.view];
    
    testWrap.isAccessibilityElement = false;
    testWrap.accessibilityFrame = testWrapFrame;
    testWrap.accessibilityNavigationStyle = UIAccessibilityNavigationStyleCombined; //Property specific to Switch Control.
    testWrap.accessibilityElements = @[testOneButton, testTwoButton];
    
    
    //Creation of the 'secondGroup' SEPARATING the first two buttons.
    CGRect secondGroupRect = CGRectUnion(_btn1.frame, _btn2.frame);
    CGRect secondGroupFrame = [_btnsParentView convertRect:secondGroupRect
                                                    toView:self.view];
    UIAccessibilityElement * secondGroup = [[UIAccessibilityElement alloc]initWithAccessibilityContainer:_btnsParentView];
    
    secondGroup.isAccessibilityElement = false;
    secondGroup.accessibilityFrame = secondGroupFrame;
    secondGroup.accessibilityNavigationStyle = UIAccessibilityNavigationStyleSeparate;
    secondGroup.accessibilityElements = @[_btn1, _btn2];

    
    //Creation of the 'thirdGroup' COMBINING the last two buttons.
    CGRect thirdGroupRect = CGRectUnion(_btn5.frame, _btn6.frame);
    CGRect thirdGroupFrame = [_btnsParentView convertRect:thirdGroupRect
                                                   toView:self.view];
    UIAccessibilityElement * thirdGroup = [[UIAccessibilityElement alloc]initWithAccessibilityContainer:_btnsParentView];
    
    thirdGroup.isAccessibilityElement = false;
    thirdGroup.accessibilityFrame = thirdGroupFrame;
    thirdGroup.accessibilityNavigationStyle = UIAccessibilityNavigationStyleCombined;
    thirdGroup.accessibilityElements = @[_btn5, _btn6];
    
    
    self.view.accessibilityElements = @[testWrap, 
                                        secondGroup, 
                                        thirdGroup];
}
@end
</code></pre>
<pre><code class="swift">
class ViewController: UIViewController {
    
    @IBOutlet weak var btnsParentView: UIStackView!
    @IBOutlet weak var btn1: UIButton!
    @IBOutlet weak var btn2: UIButton!
    @IBOutlet weak var btn5: UIButton!
    @IBOutlet weak var btn6: UIButton!
    
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        //Creation of the first group 'testWrap' COMBINING the 'Test_1' and 'Test_2' buttons.
        let testOneButton = self.view.viewWithTag(1) as? UIButton
        let testTwoButton = self.view.viewWithTag(2) as? UIButton
        let testWrapFrame = testOneButton?.frame.union((testTwoButton?.frame)!)

        let testWrap = UIAccessibilityElement(accessibilityContainer: self.view!)

        testWrap.isAccessibilityElement = false
        testWrap.accessibilityFrame = testWrapFrame!
        testWrap.accessibilityNavigationStyle = .combined   //Property specific to Switch Control.
        testWrap.accessibilityElements = [testOneButton!, testTwoButton!]


        //Creation of the 'secondGroup' SEPARATING the first two buttons.
        let secondGroupRect = btn1.frame.union(btn2.frame)
        let secondGroupFrame = btnsParentView.convert(secondGroupRect,
                                                      to: self.view)
        let secondGroup = UIAccessibilityElement(accessibilityContainer: btnsParentView!)

        secondGroup.isAccessibilityElement = false
        secondGroup.accessibilityFrame = secondGroupFrame
        secondGroup.accessibilityNavigationStyle = .separate
        secondGroup.accessibilityElements = [btn1!, btn2!]


        //Creation of the 'thirdGroup' COMBINING the last two buttons.
        let thirdGroupRect = btn5.frame.union(btn6.frame)
        let thirdGroupFrame = btnsParentView.convert(thirdGroupRect,
                                                     to: self.view)
        let thirdGroup = UIAccessibilityElement(accessibilityContainer: btnsParentView!)

        thirdGroup.isAccessibilityElement = false
        thirdGroup.accessibilityFrame = thirdGroupFrame
        thirdGroup.accessibilityNavigationStyle = .combined
        thirdGroup.accessibilityElements = [btn5!, btn6!]


        self.view.accessibilityElements = [testWrap,
                                           secondGroup, 
                                           thirdGroup]
    }
}
</code></pre>
<p><br>The visual rendering is exposed hereunder :<br>
<br><img alt="visual rendering screenshot" style="max-width: 1100px; height: auto; " src="../../images/iOSdev/SwitchControl_1.png" /><br>
<br>Once activated, the created groups allow to reach directly the elements which they contain.</p>
</div>
<div class="tab-pane" id="switchCtrl-Link" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615200-accessibilitynavigationstyle"><code>accessibilityNavigationStyle</code></a></li>
</ul>
</div>
</div><br><br>
<h2 id="vocalized-application-name">Vocalized application name <a class="header-anchor" href="#vocalized-application-name" aria-labelledby="a11y_heading_anchor_label">#</a></h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#appName-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#appName-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#appName-Link" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="appName-Description"
     role="tabpanel">
<p>The same result as the <a href="../voiceover#CustomLabel" style="text-decoration: underline;">VoiceOver gesture</a> to set a custom label can be reached by code.<br>
<br>The rationale behind is to render a better vocalisation for an application name that could be very obscure according to its written abbreviation.</p>
</div>
<div class="tab-pane" id="appName-Example" role="tabpanel">
<p><strong>CFBundleSpokenName</strong> is the property list key that vocally replaces an application name and might take many different translations depending on the foreign languages.<br>
<br><img alt="" style="max-width: 750px; height: auto; " src="../../images/iOSdev/AppName_1.png" /><br>
<br>In the end, we go from a weird to an understandable vocalized name that is defined upstream with no user modifications.<br>
<br><img alt="" style="max-width: 600px; height: auto; " src="../../images/iOSdev/AppName_2.png" /></p>
</div>
<div class="tab-pane" id="appName-Link" role="tabpanel">
<ul>
<li><a href="https://developer.apple.com/documentation/bundleresources/information_property_list/cfbundlespokenname"><code>CFBundleSpokenName</code></a></li>
</ul>
</div>
</div><br><br>

    </main>
    <footer id="footer" class="o-footer" role="contentinfo">
  <div class="container-lg">
    <nav class="py-2" role="navigation">
      <ul class="nav flex-column flex-sm-row"><li class="nav-item">
            <a href="/en/contact" class="nav-link"><u>Contact</u></a>
          </li><li class="nav-item">
            <a href="/en/about" class="nav-link"><u>About</u></a>
          </li><li class="nav-item ml-sm-auto">
          <a href="https://github.com/Orange-OpenSource/a11y-guidelines/issues/new?title=File%20path%20:%20'./src/en/mobile/ios/development.md'" class="nav-link" rel="noopener noreferrer" target="_blank" title="Report an error on Github (new window)">
            <u>Report an error on Github<span class="sr-only">&nbsp;(new window)</span><svg width="16" height="16" class="ml-1" viewBox="0 0 1000 1000" aria-hidden="true" focusable="false"><path class="cls-1" d="M374.908,308.958L600,309V109L921.719,430.9a74.988,74.988,0,0,1,0,106.044L600,859V659H325A150.027,150.027,0,0,0,175,809v81C98.941,830.528,50,737.929,50,633.891,50,454.436,195.466,308.958,374.908,308.958Z"/></svg></u>
          </a>
        </li>
      </ul>
    </nav>
  </div>
</footer>

    <a href="#" id="back-to-top" class="o-scroll-up static" title="Back to top">
      <span class="d-none d-sm-inline-block">Back to top</span>
    </a>
    <script src="/assets/vendors/tarteaucitronjs/tarteaucitron.js"></script>
    
      <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.1/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
    
    
      <script src="https://cdn.jsdelivr.net/npm/boosted@4.5.2/dist/js/boosted.min.js" integrity="sha384-Ochdn7tEptQMWvKZ+UJHlK48cRq+lpQfD+cvNHas5cOG62XdpPFzZDjO303+fISm" crossorigin="anonymous"></script>
    
    
    
      <script src="/assets/vendors/highlightjs/highlight.js"></script>
    
    <script>
      const Application = {
        lang: "en",
        vendors: {
          highlightJS: true
        }
      }
    </script>
    <script src="/assets/script.js"></script><script>
      var tarteaucitronForceLanguage = "en"
      tarteaucitron.init({"privacyUrl":"","hashtag":"#cookie-consent","cookieName":"cookie-consent","orientation":"bottom","showAlertSmall":false,"cookieslist":true,"adblocker":false,"AcceptAllCta":true,"highPrivacy":true,"handleBrowserDNTRequest":false,"removeCredit":false,"moreInfoLink":true,"useExternalCss":true,"readmoreLink":"/cookiespolicy","mandatory":false});tarteaucitron.user.googletagmanagerId = "GTM-N3M5VXS";
        (tarteaucitron.job = tarteaucitron.job || []).push('googletagmanager')</script>
    <div id="a11y_heading_anchor_label" hidden>Anchor link</div>
    <!--  This file is part of a11y-guidelines | Our vision of mobile & web accessibility guidelines and best practices, with valid/invalid examples. Copyright (C) 2016 - 2020 Orange SA. See the Creative Commons Legal Code Attribution-ShareAlike 3.0 Unported License for more details (LICENSE file). -->

  </body>
</html>
