<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Orange digital accessibility guidelines</title>
        
      
      <!-- Copyright © 2014 Monotype Imaging Inc. All rights reserved -->
      <link rel="stylesheet" href="/boosted/css/orangeHelvetica.css">
      <!-- Copyright © 2016 Orange SA. All rights reserved -->
      <link rel="stylesheet" href="/boosted/css/orangeIcons.css">
      <link rel="stylesheet" href="/boosted/css/boosted.css">

      <!-- Style pour la mise en forme des exemples de code -->
      <link rel="stylesheet" href="/css/dark.min.css">

      <!-- Styles perso -->
      <link rel="stylesheet" href="/css/reco.css">
      <link rel="stylesheet" href="./css/reco-custom.css">

      <script src="/js/jquery.min.js"></script>
      <script src="/js/jquery.validate.min.js"></script>
      <script type="text/javascript" src="./js/lunr.min.js"></script>

      <!-- Favicons -->
      <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
      <link rel="icon" href="/images/favicon.ico">                  
</head>
<body>
    <div class="skip-links sr-only">
        <a id="skip-nav" href="#sidebar">Skip to navigation</a>
        <a id="skip-content" href="#content">Skip to main content</a>
    </div>
    <header role="banner">
      <nav class="navbar navbar-dark navbar-fixed-top">
          <button class="navbar-toggler hidden-sm-up" type="button" data-toggle="collapse" data-target="#collapsingNavbar">
              <span class="sr-only">Navigation bar</span>
              <span class="icon-menu"></span>
          </button>
          
              <a href="index.html" class="navbar-brand"><img src="/images/master_logo_rwd.svg" alt="Back to home" title="Back to home"/></a>
              <ul class="nav navbar-nav collapse navbar-toggleable-xs pull-xs-left" id="collapsingNavbar">
                  <li class="nav-item"><a class="nav-link" href="../home_EN/index.html">Home</a></li>             
                  <li class="nav-item">
                    <a class="nav-link" href="../web_EN/index.html">Web</a> 
                  </li>
                  <li class="nav-item active mobile">
                    <a href="./index.html" 
                       class="nav-link">Mobile
                      </a>
                    <ul id="navigation" class="nav navbar-nav">
                      <li><a class="page-index" 
                             href="index.html">Presentation
                          </a>
                        </li>
                      <li><a class="page-mobile-android" 
                               href="mobile-android.html" 
                               aria-haspopup="true" 
                               aria-expanded="false">Android
                            </a>
                        </li>  
                        <li><a class="page-mobile-ios" 
                               href="mobile-ios.html" 
                               aria-haspopup="true" 
                               aria-expanded="false">iOS
                            </a>
                        </li>          
                      <li><a class="page-mdan" 
                             href="mdan.html">mDAN
                          </a>
                        </li>
                      <li><a class="page-links" 
                             href="links.html">Useful links
                          </a>
                        </li>
                      <li><a class="page-contact" 
                             href="contact.html">Contact
                          </a>
                        </li>
                      <li><a class="page-about" 
                             href="about.html">About
                          </a>
                        </li>                        
                    </ul>                      
                  </li>  
                  <li class="nav-item"><a href="../others_EN/index.html" class="nav-link">Editorial content</a></li>
                  <li class="nav-item language hidden-sm-up">
                    <a href="../mobile/index.html" class="nav-link" lang="fr" aria-label="version française">fr</a><a aria-disabled="true" aria-label="english version" href="#" class="nav-link active">en</a>
                  </li>
              </ul> 
              <ul class="nav navbar-nav pull-xs-right" id="secondNavBar">        
                <li class="nav-item hidden-xs-down">
                  <span id="cdu">                  
                    <a href="http://confort-plus.orange.com/index_en" target="_blank" 
                      title="Discover Confort +: browser extension allowing to adapt the reading comfort when consulting a website." 
                      aria-label="Discover Confort +: browser extension allowing to adapt the reading comfort when consulting a website.">
                      Discover Confort
                      <span>+</span>
                    </a>
                  </span>
                </li>
                <li class="nav-item language hidden-xs-down">
                  <a href="../mobile/index.html" class="nav-link" lang="fr" aria-label="version française">fr</a><a aria-disabled="true" aria-label="english version" href="#" class="nav-link active">en</a> 
                </li>
                <li class="nav-item">
                    <a href="#searchbar" class="nav-link icon" id="searchIcon" data-toggle="collapse" aria-expanded="false" aria-controls="searchbar">
                        <span class="sr-only">Display search bar</span>
                        <span class="icon-search" aria-hidden="true"></span>
                    </a>                    
                </li>                
            </ul>             
          
          <form action="./search.html" class="navbar-form navbar-right collapse" role="search" id="searchbar">
            <label for="search">Search</label>
            <input placeholder="Enter your search" type="text" id="search" name="q">
            <button type="submit" class="btn btn-secondary icon">
              <span class="sr-only">Search</span>
              <span class="icon-search" aria-hidden="true"></span>
            </button>
          </form>
      </nav>      
    </header>

    <nav>
      <span class="sr-only">You are here: </span>
      <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="/mobile_EN/index.html">Mobile app</a></li>        
      </ol>
    </nav>
    
    <main role="main" class="container-fluid">
      <div class="row row-offcanvas row-offcanvas-left">       
        <div role="navigation" id="sidebar" class="col-xs-6 col-sm-3 sidebar-offcanvas">
        </div>
        <div class="col-xs-12 col-sm-9" id="content">          
          <h1 id="ios-developer-guide">iOS developer guide</h1>
<script>$(document).ready(function () {
    setBreadcrumb([{"label":"iOS","url":"mobile-ios.html"},
                   {"label":"Developers guide"}]);
    addSubMenu([
        {"label":"Design criteria","url":"criteria-ios.html"}, 
        {"label":"Developers guide","url":"dev-ios.html", "expanded": true},
        {"label":"VoiceOver","url":"voiceover.html"},
        {"label":"WWDC","url":"dev-ios-wwdc.html"},
        {"label":"Tests","url":"criteria-ios-test.html"}
    ]);        
});</script>

<p><span data-menuitem="mobile-ios"></span></p>
<p>This guide aims to present the various iOS <abbr>SDK</abbr> accessibility options.
</br>Through different categories, it explains how to use the accessibility attributes&nbsp;/ methods and provides links to the <a href="https://developer.apple.com/documentation/uikit/accessibility"><code>Apple official documentation</code></a>.
</br>Code snippets are also available to show the different possible implementations <em>{ (Swift 5.0, Objective C) + (Xcode 10, iOS 12) }</em>.</p>
<p><a name="AccessibilityTraits"></a></p>
<h2 id="element-trait">Element trait</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#TraitElt-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#TraitElt-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#TraitElt-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#TraitElt-BasicOperations" 
           role="tab" 
           aria-selected="false">Basic operations</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#TraitElt-Links" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="TraitElt-Description"
     role="tabpanel">
The `accessibilityTraits` attribute allows to specify the trait of an element to the accessibility <abbr>API</abbr>.
</br>Then, the `accessibilityTrait` attribute **plays an important role on the element vocalization** because it enables VoiceOver to recognize its type.  

</div>
<div class="tab-pane" id="TraitElt-Details" role="tabpanel" >
This accessibility attribute is available via the interface builder but also programmatically.
</br></br>There are many available traits. The most commonly used are:  
- **accessibilityTraitNone**&nbsp;: removes any semantic value to the element.
- **accessibilityTraitButton**&nbsp;: adds the “button” trait, the element is seen as a button by VoiceOver.
- **accessibilityTraitLink**&nbsp;: useful to define a label as a “link”.
- **accessibilityTraitHeader**&nbsp;: defines an element as a header *(see the <a href="criteria-ios.html#title-and-header">«&nbsp;Title and header&nbsp;»</a> section)*.
- **accessibilityTraitAdjustable**&nbsp;: defines an element as an “adjustable” element, that is to say an element that users can adjust in a continuous manner, such as a slider or a picker view *(see the [VoiceOver user guide](./voiceover.html))*.

</div>
<div class="tab-pane" id="TraitElt-Example" role="tabpanel" >
<pre><code class="objective-c">
- (void)customTraits() {
    //Specified UIPageControl with the ’ajustable’ trait.
    pageControl.accessibilityTraits = UIAccessibilityTraitAdjustable;

<pre><code>//Added header.  
defaultHeaderViewCell.accessibilityTraits = UIAccessibilityTraitHeader;</code></pre><p>}
</code></pre><pre><code class="swift">
func customTraits() {
    //Specified UIPageControl with the ’ajustable’ trait.
    pageControl.accessibilityTraits = .adjustable</p>
<pre><code>//Added header.  
defaultHeaderViewCell.accessibilityTraits = .header</code></pre><p>}
</code></pre></p>
</div>
<div class="tab-pane" id="TraitElt-BasicOperations" role="tabpanel" >
The `accessibilityTrait` attribute is actually a `bitmask` in which each element has its own value.
</br><img alt="" style="max-width: 600px; height: auto; " src="./images/iOSdev/Traits.png" />
</br>It's then possible to add and remove some `traits` after having checked their existence in the bitmask for instance.

<pre><code class="objective-c">
- (void)changeTraits {

    //Dedicated trait set with no other option.
    onePageButton.accessibilityTraits = UIAccessibilityTraitButton | UIAccessibilityTraitLink;

    //Added traits to the existing ones.
    pageControl.accessibilityTraits |= UIAccessibilityTraitHeader; //Only one trait.
    pageControl.accessibilityTraits |= UIAccessibilityTraitButton + UIAccessibilityTraitLink; //Many traits.

    //Remove a trait.
    onePageButton.accessibilityTraits &= ~UIAccessibilityTraitLink;

    //Check out the bitmask trait existence.
    if ((pageControl.accessibilityTraits & UIAccessibilityTraitHeader) != 0) {
        // Do the job if '.header' is one of the traits...
    }
}
</code></pre><pre><code class="swift">
<p>func changeTraits() {</p>
<pre><code>//Dedicated trait set with no other option.
onePageButton.accessibilityTraits = [.button, .link]

//Added traits to the existing ones.
pageControl.accessibilityTraits.insert(.header) //Only one trait.
pageControl.accessibilityTraits.formUnion([.button, .link]) //Many traits.

//Remove a trait.
onePageButton.accessibilityTraits.remove(.link)

//Check out the bitmask trait existence.
if (pageControl.accessibilityTraits.rawValue &amp; UIAccessibilityTraits.header.rawValue == UIAccessibilityTraits.header.rawValue) {
    // Do the job if &#39;.header&#39; is one of the traits...
}</code></pre><p>}
</code></pre></p>
</div>
<div class="tab-pane" id="TraitElt-Links" role="tabpanel" >
- [`accessibilityTraits`](https://developer.apple.com/documentation/objectivec/nsobject/1615202-accessibilitytraits)
</div>
</div></br></br>
<h2 id="text-alternatives">Text alternatives</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#textAlt-Details" 
           role="tab" 
           aria-selected="true">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#textAlt-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#textAlt-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="textAlt-Details"
     role="tabpanel">
On iOS, the vocalization of an element is done through four attributes: `label`, `hint`, `value` and `trait`.
The order of vocalization is always as follows: `label`, `value`, `trait` and `hint`. This order cannot be changed and the vocalization is performed only once.
</br></br>A section of this guide is dedicated to the <a href="#AccessibilityTraits" style="text-decoration: underline;">trait</a>, we describe here the other three:
- **accessibilityLabel**&nbsp;: the `label` redefines the text read by VoiceOver. This allows a component to be more explicit than the text displayed on the screen. For example, for a button whose title is “OK”, this attribute can indicate that the button is used to confirm an action.
- **accessibilityValue**&nbsp;: the `value` of an element is by default the completion percentage (e.g. a progress bar percentage). Note that for most elements available in the <abbr>SDK</abbr>, this value does not need to be set (the system automatically sets the value).
- **accessibilityHint**&nbsp;: the `hint` describes the component’s behaviour. Example: “click here to get the result”.

<p>These accessibility attributes are available via the builder interface but also programmatically. Anything inheriting from <code>UIView</code> has these attributes by default. These attributes accept an optional string, and are therefore easily localizable.</p>
</div>
<div class="tab-pane" id="textAlt-Example" role="tabpanel" >   
<pre><code class="objective-c">
@interface ChangeTextView() {

<pre><code>__weak IBOutlet UILabel * myLabel;
__weak IBOutlet UIProgressView * myProgressView;</code></pre><p>}
@end</p>
<p>@implementation ChangeTextView</p>
<ul>
<li><p>(void)viewDidAppear:(BOOL)animated {
  [super viewDidAppear:animated];</p>
<p>  myLabel.accessibilityLabel = @&quot;hello&quot;;
  myLabel.accessibilityHint = @&quot;This is an added comment.&quot;;</p>
<p>  myProgressView.accessibilityValue = @&quot;45 per cent&quot;;
}
@end
</code></pre><pre><code class="swift">
class ChangeTextView: UIViewController {</p>
<p>  @IBOutlet weak var myLabel: UILabel!
  @IBOutlet weak var myProgressView: UIProgressView!</p>
<p>  override func viewDidAppear(_ animated: Bool) {</p>
<pre><code>  super.viewDidAppear(animated)

  myLabel.accessibilityLabel = &quot;hello&quot;
  myLabel.accessibilityHint = &quot;This is an added comment.&quot;

  myProgressView.accessibilityValue = &quot;45 per cent&quot;</code></pre><p>  }
}
</code></pre></p>
</li>
</ul>
</div>
<div class="tab-pane" id="textAlt-Links" role="tabpanel" > 
- [`accessibilityLabel`](https://developer.apple.com/documentation/objectivec/nsobject/1615181-accessibilitylabel)
- [`accessibilityValue`](https://developer.apple.com/documentation/objectivec/nsobject/1615117-accessibilityvalue)
- [`accessibilityHint`](https://developer.apple.com/documentation/objectivec/nsobject/1615093-accessibilityhint)
</div>
</div></br></br>
<h2 id="date-time-and-numbers">Date, time and numbers</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#format-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#format-DateTime" 
           role="tab" 
           aria-selected="false">Date & Time</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#format-Numbers" 
           role="tab" 
           aria-selected="false">Numbers</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#format-PhoneNumbers" 
           role="tab" 
           aria-selected="false">Phone numbers</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="format-Description"
     role="tabpanel">
Using VoiceOver for reading date, time and numbers may become rapidly a headache if some steps fade into obscurity.

</div>
<div class="tab-pane" id="format-DateTime" role="tabpanel" >
The rendering isn't natural if the date or time data are imported text in a `label`.
</br><img alt="" style="max-width: 800px; height: auto; " src="./images/iOSdev/DateHeureNombres_11.png" />
</br>Incoming data must be formatted to obtain a natural and understandable descriptive vocalization.
</br><img alt="" style="max-width: 800px; height: auto; " src="./images/iOSdev/DateHeureNombres_7.png" />
<pre><code class="objective-c">
    NSDateFormatter * dateFormatter = [[NSDateFormatter alloc]init];
    [dateFormatter setDateFormat:@"dd/MM/yyyy HH:mm"];

<pre><code>NSDate * date = [dateFormatter dateFromString:@&quot;01/04/2015 05:30&quot;];

dateLabel.text = [NSDateFormatter localizedStringFromDate:date
                                                dateStyle:NSDateFormatterShortStyle
                                                timeStyle:NSDateFormatterNoStyle];

dateLabel.accessibilityLabel = [NSDateFormatter localizedStringFromDate:date
                                                              dateStyle:NSDateFormatterMediumStyle
                                                              timeStyle:NSDateFormatterNoStyle];


hourLabel.text = [NSDateFormatter localizedStringFromDate:date
                                                dateStyle:NSDateFormatterNoStyle
                                                timeStyle:NSDateFormatterShortStyle];

NSDateComponents * hourComponents = [[NSCalendar currentCalendar] components:NSCalendarUnitHour | NSCalendarUnitMinute
                                                                    fromDate:date];

hourLabel.accessibilityLabel = [NSDateComponentsFormatter localizedStringFromDateComponents:hourComponents
                                                                                 unitsStyle:NSDateComponentsFormatterUnitsStyleSpellOut];</code></pre><p></code></pre><pre><code class="swift">
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "dd/MM/yyyy HH:mm"</p>
<pre><code>let date = dateFormatter.date(from: &quot;01/04/2015 05:30&quot;)

dateLabel.text = DateFormatter.localizedString(from: date!,
                                               dateStyle: .short,
                                               timeStyle: .none)

dateLabel.accessibilityLabel = DateFormatter.localizedString(from: date!,
                                                             dateStyle: .medium,
                                                             timeStyle: .none)


hourLabel.text = DateFormatter.localizedString(from: date!,
                                               dateStyle: .none,
                                               timeStyle: .short)

let hourComponents = Calendar.current.dateComponents([.hour, .minute],
                                                     from: date!)
hourLabel.accessibilityLabel = DateComponentsFormatter.localizedString(from: hourComponents,
                                                                       unitsStyle: .spellOut)</code></pre><p></code></pre></p>
</div>
<div class="tab-pane" id="format-Numbers" role="tabpanel" >
If a number is imported as is in a `label`text, the vocalization will be made on each figure rendering a final value that may be hard to be well understood.
</br><img alt="" style="max-width: 475px; height: auto; " src="./images/iOSdev/DateHeureNombres_12.png" />
</br>As the previous sheet dealing with date and time, the incoming data must be formatted to be analyzed and vocalized according to the proper value of the explained number.
</br><img alt="" style="max-width: 700px; height: auto; " src="./images/iOSdev/DateHeureNombres_8.png" />
<pre><code class="objective-c">
    NSNumber * numberValue = @54038921.7;

<pre><code>NSNumberFormatter * numberFormatter = [[NSNumberFormatter alloc]init];
numberFormatter.numberStyle = NSNumberFormatterDecimalStyle;

numberLabel.text = [numberFormatter stringFromNumber:numberValue];

numberLabel.accessibilityLabel = [NSNumberFormatter localizedStringFromNumber:numberValue
                                                                  numberStyle:NSNumberFormatterSpellOutStyle];</code></pre><p></code></pre><pre><code class="swift">
    let numberValue = NSNumber(value: 54038921.7)</p>
<pre><code>numberLabel.text = NumberFormatter.localizedString(from: numberValue,
                                                   number: .decimal)

numberLabel.accessibilityLabel = NumberFormatter.localizedString(from: numberValue,
                                                                 number: .spellOut)</code></pre><p></code></pre></p>
</div>
<div class="tab-pane" id="format-PhoneNumbers" role="tabpanel" >
Once more, formatting data is an essential step for a phone number vocalization including the special cases of the "0" figures.
</br>The example hereunder deals with the french dialing but the rationale behind may be applied to any international type of dialing format.
</br><img alt="default vocalization is not valid for the following phone number : 06.11.22.33.06" style="max-width: 550px; height: auto; " src="./images/iOSdev/DateHeureNombres_10.png" />
</br>The idea of this format is based on a comma separation of each pair of figures that will provide the vocal punctuation.
</br><img alt="in this case the phone number is well vocalized" style="max-width: 550px; height: auto; " src="./images/iOSdev/DateHeureNombres_9.png" />
<pre><code class="objective-c">
    NSString * phoneNumberValue = @"06.11.22.33.06";
    NSArray * phoneNumberElts = [phoneNumberValue componentsSeparatedByString:@"."];

<pre><code>NSNumberFormatter * nbFormatter = [[NSNumberFormatter alloc]init];
nbFormatter.numberStyle = NSNumberFormatterSpellOutStyle;

NSMutableString * spelledOutString = [[NSMutableString alloc]init];

[phoneNumberElts enumerateObjectsUsingBlock:^(id  _Nonnull obj,
                                              NSUInteger idx,
                                              BOOL * _Nonnull stop) {
    NSString * elt = (NSString *)obj;

    if (idx != 0) {
        [spelledOutString appendString:@&quot;,&quot;];
    }

    if ([elt hasPrefix:@&quot;0&quot;]) {

        NSString * firstFigure = [nbFormatter stringFromNumber:@([[elt substringToIndex:1] integerValue])];
        NSString * secondFigure = [nbFormatter stringFromNumber:@([[elt substringFromIndex:1] integerValue])];

        [spelledOutString appendString:firstFigure];
        [spelledOutString appendString:secondFigure];

    } else {
        [spelledOutString appendString:[nbFormatter stringFromNumber:@([elt integerValue])]];
    }
}];

phoneNumberLabel.text = phoneNumberValue;
phoneNumberLabel.accessibilityLabel = spelledOutString;</code></pre><p></code></pre><pre><code class="swift">
        let phoneNumberValue = "06.11.22.33.06"
        let phoneNumberElts = phoneNumberValue.components(separatedBy: ".")</p>
<pre><code>    let nbFormatter = NumberFormatter()
    nbFormatter.numberStyle = .spellOut

    var spelledOutString = String()

    for (index, elt) in phoneNumberElts.enumerated() {

        if (index != 0) {
            spelledOutString.append(&quot;,&quot;)
        }

        if (elt.hasPrefix(&quot;0&quot;)) {

            let firstFigureValue = Int(String(elt[elt.startIndex]))!
            let firstFigure = nbFormatter.string(from: NSNumber(value:firstFigureValue))
            spelledOutString.append(firstFigure!)

            let secondFigureValue = Int(String(elt[elt.index(elt.startIndex, offsetBy: 1)]))!
            let secondFigure = nbFormatter.string(from: NSNumber(value:secondFigureValue))
            spelledOutString.append(secondFigure!)

        } else {

            let figure = nbFormatter.string(from: NSNumber(value:Int(elt)!))
            spelledOutString.append(figure!)
        }
    }

    phoneNumberLabel.text = phoneNumberValue
    phoneNumberLabel.accessibilityLabel = spelledOutString</code></pre><p></code></pre></p>
</div>
</div></br></br>
<h2 id="trigger-a-vocalization">Trigger a vocalization</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#triggerVocal-Details" 
           role="tab" 
           aria-selected="true">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#triggerVocal-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#triggerVocal-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="triggerVocal-Details"
     role="tabpanel">
To trigger a vocalization, just call the **UIAccessibilityPostNotification** method passing the notification allowing to trigger a vocalization (**UIAccessibilityAnnouncementNotification**) and the string to vocalize as parameters.
</br></br>Note: the vocalization is done in the system’s language.

</div>
<div class="tab-pane" id="triggerVocal-Example" role="tabpanel" >
<pre><code class="objective-c">
UIAccessibilityPostNotification(UIAccessibilityAnnouncementNotification, 
                                @"This is a VoiceOver message.");
</code></pre><pre><code class="swift">
UIAccessibility.post(notification: .announcement,
                     argument: "This is a VoiceOver message.")
</code></pre>

</div>
<div class="tab-pane" id="triggerVocal-Links" role="tabpanel" >  
- [`UIAccessibilityPostNotification`](https://developer.apple.com/documentation/uikit/1615194-uiaccessibilitypostnotification)
- [`UIAccessibilityAnnouncementNotification`](https://developer.apple.com/documentation/uikit/uiaccessibilityannouncementnotification)
</div>
</div></br></br>
<h2 id="change-the-vocalization-language">Change the vocalization language</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#changeLang-Details" 
           role="tab" 
           aria-selected="true">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#changeLang-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#changeLang-Links" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="changeLang-Details"
     role="tabpanel">
To change the vocalization language of VoiceOver for a word or a sentence, one can use the **accessibilityLanguage**&nbsp; attribute.
</br>Available through the `UIAccessibility` informal protocol, this attribute allows to specify a language for a dedicated text.

</div>
<div class="tab-pane" id="changeLang-Example" role="tabpanel" >
If we use the `accessibilityLanguage` attribute on a `UILabel`, it will be vocalized by <span lang="en">VoiceOver</span> in the language set on this attribute.
<pre><code class="objective-c">
- (IBAction)tapHere:(UIButton *)sender {

<pre><code>myLabel.accessibilityLanguage = @&quot;fr&quot;;
myLabel.accessibilityLabel = @&quot;Ceci est un nouveau label. Merci.&quot;;
UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);</code></pre><p>}
</code></pre><pre><code class="swift">
@IBAction func tapHere(_ sender: UIButton) {</p>
<pre><code>myLabel.accessibilityLanguage = &quot;fr&quot;
myLabel.accessibilityLabel = &quot;Ceci est un nouveau label. Merci.&quot;
UIAccessibility.post(notification: UIAccessibility.Notification.layoutChanged,
                     argument: myLabel)</code></pre><p>}
</code></pre></p>
</div>
<div class="tab-pane" id="changeLang-Links" role="tabpanel" >  
- [`accessibilityLanguage`](https://developer.apple.com/documentation/objectivec/nsobject/1615192-accessibilitylanguage)
</div>
</div></br></br>
<h2 id="notify-a-content-change">Notify a content change</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#changeNotif-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#changeNotif-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#changeNotif-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#changeNotif-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="changeNotif-Description"
     role="tabpanel">
When there is a content change in the current page, it is possible to notify the accessibility <abbr>API</abbr> using several types of notifications.
</br>To do that, we must send the change notification to the accessibility <abbr>API</abbr> using the following `UIAccessibilityPostNotification` method.  

</div>
<div class="tab-pane" id="changeNotif-Details" role="tabpanel" >
There are several types of change notifications but the most two commonly used are:
- **UIAccessibilityLayoutChangedNotification**&nbsp;: notifies that a part of the page has changed with 2 possible incoming parameters (a `NSString` or a `UIObject`).
</br>With a `NSString`, the notification behaves like a **UIAccessibilityAnnouncementNotification** with a <span lang="en">VoiceOver</span> vocalization.
</br>With a `UIObject`, focus is shifted to the user interface element.
</br>This notification is very similar to the **UIAccessibilityAnnouncementNotification** but should come as a result of dynamic content being deleted or added to the current view.
- **UIAccessibilityScreenChangedNotification**&nbsp;: notifies that the whole page has changed including `nil` or a `UIObject` as incoming parameters.  
With `nil`, the first accessible element in the page is focused.
</br>With a `UIObject`, focus is shifted to the specified element with a <span lang="en">VoiceOver</span>.
</br>This notification comes along with a vocalization including a sound like announcing a new page.

</div>
<div class="tab-pane" id="changeNotif-Example" role="tabpanel" >
<pre><code class="objective-c">
//The element 'myLabel' is focused and vocalized with its new value.
- (IBAction)tapHere:(UIButton *)sender {

<pre><code>myLabel.accessibilityLabel = @&quot;This is a new label.&quot;;
UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);</code></pre><p>}</p>
<p>//The first accessible element in the page is focused and vocalized with a sound like announcing a new page.</p>
<ul>
<li><p>(IBAction)clic:(UIButton *)sender {</p>
<p>  UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, nil);
}
</code></pre><pre><code class="swift">
//The element 'myLabel' is focused and vocalized with its new value.
@IBAction func tapHere(_ sender: UIButton) {</p>
<p>  myLabel.accessibilityLabel = "This is a new label."
  UIAccessibility.post(notification: UIAccessibility.Notification.layoutChanged,</p>
<pre><code>                   argument: myLabel)</code></pre><p>}</p>
</li>
</ul>
<p>//The first accessible element in the page is focused and vocalized with a sound like announcing a new page.
@IBAction func clic(_ sender: UIButton) {</p>
<pre><code>UIAccessibility.post(notification: UIAccessibility.Notification.screenChanged,
                     argument: nil)</code></pre><p>}
</code></pre></p>
</div>
<div class="tab-pane" id="changeNotif-Links" role="tabpanel" >
- [`UIAccessibilityPostNotification`](https://developer.apple.com/documentation/uikit/1615194-uiaccessibilitypostnotification)
- [`UIAccessibilityLayoutChangedNotification`](https://developer.apple.com/documentation/uikit/uiaccessibilitylayoutchangednotification)
- [`UIAccessibilityScreenChangedNotification`](https://developer.apple.com/documentation/uikit/uiaccessibilityscreenchangednotification)
- [`UIAccessibilityPageScrolledNotification`](https://developer.apple.com/documentation/uikit/uiaccessibilitypagescrollednotification)
</div>
</div></br></br>
<h2 id="hide-elements">Hide elements</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#hideElts-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#hideElts-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#hideElts-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#hideElts-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="hideElts-Description"
     role="tabpanel">
It is possible via an accessibility attribute to hide elements from accessibility tools (e.g. VoiceOver).
</br>By extension, it is possible to force some elements to be visible to accessibility tools.

</div>
<div class="tab-pane" id="hideElts-Details" role="tabpanel" >
- **isAccessibilityElement**: boolean to specify that an element is visible or not to the Accessibility <abbr>API</abbr> (VoiceOver or other).
- **accessibilityElementsHidden**: boolean to indicate that the children elements of the target element are visible or not to the Accessibility <abbr>API</abbr>.
- **accessibilityViewIsModal**: boolean that can make visible or not the sibling elements of the target element to the Accessibility <abbr>API</abbr>.
</br>A [theoretical explanation](./dev-ios-wwdc-18230.html#accessibilityViewIsModal) and a [practical example](./dev-ios-wwdc-18230.html#DemoModalView) are provided in a video detailed in the WWDC part.

<p>The <code>accessibilityElement</code> attribute is available via the interface builder but can also be used directly through the code.
</br>The other two attributes are available only through the code.</p>
</div>
<div class="tab-pane" id="hideElts-Example" role="tabpanel" >
A red square will be drawn and contain two other squares (blue and yellow) in order to apply the attributes defined in the `Details` sheet.

<img alt="" style="max-width: 500px; height: auto; " src="./images/iOSdev/MasquerDesElements_1.png" />
<pre><code class="objective-c">
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

<pre><code>//Creation of an element inside which 2 other children elements will be inserted.
CGRect redParentViewRect = CGRectMake(100.0, 100.0, 40.0, 40.0);
UIView * myRedParentView = [[UIView alloc]initWithFrame:redParentViewRect];
myRedParentView.backgroundColor = [UIColor redColor];

[self.view addSubview:myRedParentView];

//The target element musn&#39;t be accessible so as to be considered as a container to its children elements.
//If this attribute is &#39;YES&#39;, the target element will be the only one accessible element.
myRedParentView.isAccessibilityElement = NO;

//The elements contained in the target element won&#39;t be accessible even if they&#39;re defined as such.
//If this attribute is &#39;NO&#39; and the previous one is &#39;NO&#39;, only the children elements will be accessible.
myRedParentView.accessibilityElementsHidden = NO;

[self createViewWithColor:[UIColor yellowColor] 
                   inside:myRedParentView];
[self createViewWithColor:[UIColor blueColor] 
                   inside:myRedParentView];</code></pre><p>}</p>
<ul>
<li><p>(void)createViewWithColor:(UIColor*)color</p>
<pre><code>               inside:(UIView*)parentView {</code></pre><p>  float delta = (color == [UIColor yellowColor]) ? 0.0 : 20.0;</p>
<p>  CGRect rect = CGRectMake(10.0 + delta, 10.0 + delta, 10.0, 10.0);
  UIView * theView = [[UIView alloc]initWithFrame:rect];
  theView.backgroundColor = color;</p>
<p>  [parentView addSubview:theView];</p>
<p>  theView.isAccessibilityElement = YES;
}
</code></pre><pre><code class="swift">
override func viewDidAppear(_ animated: Bool) {</p>
<pre><code>  super.viewDidAppear(animated)

  //Creation of an element inside which 2 other children elements will be inserted.
  let redParentViewRect = CGRect.init(x: 100.0,
                                      y: 100.0,
                                      width: 40.0,
                                      height: 40.0)
  let myParentView = UIView.init(frame: parentViewRect)
  myRedParentView.backgroundColor = .red

  self.view.addSubview(myRedParentView)

  //The target element musn&#39;t be accessible so as to be considered as a container to its children elements.
  //If this attribute is &#39;true&#39;, the target element will be the only one accessible element.
  myRedParentView.isAccessibilityElement = true

  //The elements contained in the target element won&#39;t be accessible even if they&#39;re defined as such.
  //If this attribute is &#39;false&#39; and the previous one is &#39;false&#39;, only the children elements will be accessible.
  myRedParentView.accessibilityElementsHidden = false

  self.createViewWithColor(.yellow, inside: myRedParentView)
  self.createViewWithColor(.blue, inside: myRedParentView)</code></pre><p>  }</p>
<p>  func createViewWithColor(_ color:UIColor, inside parentView:UIView) {</p>
<pre><code>  let delta:CGFloat = ((color == .yellow) ? 0.0 : 20.0)
  let rect = CGRect.init(x: 10.0 + delta,
                         y: 10.0 + delta,
                         width: 10.0,
                         height: 10.0)

  let theView = UIView.init(frame: rect)
  theView.backgroundColor = color

  parentView.addSubview(theView)

  theView.isAccessibilityElement = true</code></pre><p>  }
</code></pre></p>
</li>
</ul>
</div>
<div class="tab-pane" id="hideElts-Links" role="tabpanel" >
- [`isAccessibilityElement`](https://developer.apple.com/documentation/objectivec/nsobject/1615141-isaccessibilityelement)
- [`accessibilityElementsHidden`](https://developer.apple.com/documentation/objectivec/nsobject/1615080-accessibilityelementshidden)
- [`accessibilityViewIsModal`](https://developer.apple.com/documentation/objectivec/nsobject/1615089-accessibilityviewismodal)
</div>
</div></br></br>
<h2 id="grouping-elements">Grouping elements</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#groupElts-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#groupElts-Example1" 
           role="tab" 
           aria-selected="false">Example 1</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#groupElts-Example2" 
           role="tab" 
           aria-selected="false">Example 2</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#groupElts-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="groupElts-Description"
     role="tabpanel">
Grouping elements may be used to vocalize the bundle once and to associate a dedicated action to it.</br></br>

</div>
<div class="tab-pane" id="groupElts-Example1" role="tabpanel" >
We wish to obtain a 'label' and a 'switch control' as one unique block behaving like a `switch control`.
</br>In this case, a view must be created to encapsulate all the elements and an action must be implemented (only the container must be an accesible element).
</br><img alt="" style="max-width: 700px; height: auto; " src="./images/iOSdev/GrouperDesElements_1.png" />
</br>Create your wrapper as an accessible element :
<pre><code class="objective-c">
#import "MyViewController.h"
#import "MyWrapView.h"

<p>@interface MyViewController ()</p>
<p>@property (weak, nonatomic) IBOutlet UILabel * myLabel;
@property (weak, nonatomic) IBOutlet UISwitch * mySwitch;</p>
<p>@end</p>
<p>@implementation MyViewController</p>
<ul>
<li><p>(void)viewDidAppear:(BOOL)animated {
  [super viewDidAppear:animated];</p>
<p>  //Create the view that will encapsulate the &#39;label&#39; and the &#39;Switch Control&#39;.
  MyWrapView * wrap = [[MyWrapView alloc] initWith:_myLabel</p>
<pre><code>                                           and:_mySwitch];</code></pre><p>  [self.view addSubview:wrap];
}
@end
</code></pre><pre><code class="swift">
  class MyViewController: UIViewController {</p>
<p>  @IBOutlet weak var myLabel: UILabel!
  @IBOutlet weak var mySwitch: UISwitch!</p>
</li>
</ul>
<pre><code>override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    //Create the view that will encapsulate the &#39;label&#39; and the &#39;Switch Control&#39;.
    let wrap = MyWrapView.init(with: myLabel,
                               and: mySwitch)

    self.view.addSubview(wrap)
}</code></pre><p>}
</code></pre></p>
<p></br>... and implement the wrapper class to define accurately the
<a href="http://a11y-guidelines.orange.com/mobile_EN/dev-ios-wwdc-17215.html#DefaultActivation">action when a double tap occurs</a> :</p>
<pre><code class="objective-c">
@implementation MyWrapView

//Indexes for the array containing all the wrapped elements.
int indexLabel = 0;
int indexSwitch = 1;


- (instancetype)initWith:(UILabel *)label and:(UISwitch *)aSwitch {

    CGRect viewFrame = CGRectUnion(label.frame, aSwitch.frame);
    MyWrapView * wrapView = [[MyWrapView alloc]initWithFrame:viewFrame];

    wrapView.accessibilityElements = @[label, aSwitch];

    NSString * switchValue = (aSwitch.isOn) ? @"on" : @"off";

    wrapView.isAccessibilityElement = YES;
    wrapView.accessibilityLabel = [NSString stringWithFormat:@"the switch control is %@", switchValue.description];
    wrapView.accessibilityHint = @"tap twice to change the switch control status.";

    return wrapView;
}


//Function called by the system when a double tap occurs on the selected wrapper.
- (BOOL)accessibilityActivate {

    UISwitch * theSwitch = self.accessibilityElements[indexSwitch];
    [theSwitch setOn:!(theSwitch.isOn)];

    NSString * switchValue = (theSwitch.isOn) ? @"on" : @"off";

    self.accessibilityLabel = [NSString stringWithFormat:@"the switch control is %@", switchValue.description];
    return YES;
}
@end
</code></pre><pre><code class="swift">
<pre><code>class MyWrapView: UIView {

//Indexes for the array containing all the wrapped elements.
let indexLabel = 0
let indexSwitch = 1


override init(frame: CGRect) {
    super.init(frame: frame)
}


required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
}


convenience init(with label: UILabel,and aSwitch: UISwitch) {

    let viewFrame = label.frame.union(aSwitch.frame)
    self.init(frame: viewFrame)

    self.accessibilityElements = [label, aSwitch]

    let switchValue = (aSwitch.isOn) ? &quot;on&quot; : &quot;off&quot;

    self.isAccessibilityElement = true
    self.accessibilityLabel = &quot;the switch control is &quot; + switchValue.description
    self.accessibilityHint = &quot;tap twice to change the switch control status.&quot;
}


//Function called by the system when a double tap occurs on the selected wrapper.
override func accessibilityActivate() -&gt; Bool {

    let theSwitch = self.accessibilityElements?[indexSwitch] as? UISwitch
    theSwitch?.setOn(!((theSwitch?.isOn)!), animated: false)

    let switchValue = (theSwitch?.isOn)! ? &quot;on&quot; : &quot;off&quot;

    self.accessibilityLabel = &quot;the switch control is &quot; + switchValue.description

    return true
}</code></pre><p>}
</code></pre></p>
</div>
<a name="ActivationPointExemple"></a>
<div class="tab-pane" id="groupElts-Example2" role="tabpanel" >
We have a button, a label and a switch control to be regrouped in a single block whose activation will change the switch control status automatically without defining any action like before.
</br></br>The easiest way would be to place the switch control in the middle of the created frame in order to locate its [accessibilityActivationPoint](#AccessibilityActivationPoint) directly on it.
</br>Unfortunately, that's not always possible.
</br></br>A new accessible element must then be created to gather all the desired objects and its **accessibilityActivationPoint** has to be defined on the switch control.
</br><img alt="" style="max-width: 350px; height: auto; " src="./images/iOSdev/GrouperDesElements_2.png" />
<pre><code class="objective-c">
@interface ActivationPointViewController ()

<p>@property (weak, nonatomic) IBOutlet UIButton * myButton;
@property (weak, nonatomic) IBOutlet UILabel * myLabel;
@property (weak, nonatomic) IBOutlet UISwitch * mySwitch;</p>
<p>@end</p>
<p>@implementation ActivationPointViewController</p>
<p>UIAccessibilityElement * elt;</p>
<ul>
<li><p>(void)viewDidAppear:(BOOL)animated {
  [super viewDidAppear:animated];</p>
<p>  [_mySwitch addTarget:self</p>
<pre><code>            action:@selector(configChanged:)
  forControlEvents:UIControlEventValueChanged];</code></pre><p>  elt = [[UIAccessibilityElement alloc]initWithAccessibilityContainer:self.view];</p>
<p>  CGRect a11yFirstEltFrame = CGRectUnion(_myLabel.frame, _myButton.frame);
  CGRect a11yEltFrame = CGRectUnion(a11yFirstEltFrame, _mySwitch.frame);</p>
<p>  elt.accessibilityLabel = @&quot;regrouping elements&quot;;
  elt.accessibilityHint = @&quot;double tap to change the switch control status&quot;;
  elt.accessibilityFrameInContainerSpace = a11yEltFrame;
  elt.accessibilityActivationPoint = [_mySwitch center];</p>
<p>  self.view.accessibilityElements = @[elt];
}</p>
</li>
</ul>
<ul>
<li><p>(void)configChanged:(UISwitch *)sender {</p>
<p>  NSString * switchValue = _mySwitch.on ? @&quot;on&quot; : @&quot;off&quot;;
  elt.accessibilityLabel = [NSString stringWithFormat:@&quot;the switch control is %@&quot;, switchValue.description];
}
@end
</code></pre><pre><code class="swift">
  class ActivationPointViewController: UIViewController {</p>
<p>  @IBOutlet weak var myButton: UIButton!
  @IBOutlet weak var myLabel: UILabel!
  @IBOutlet weak var mySwitch: UISwitch!</p>
<p>  var elt: UIAccessibilityElement?</p>
</li>
</ul>
<pre><code>override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    mySwitch.addTarget(self,
                       action: #selector(configChanged),
                       for: .valueChanged)

    elt = UIAccessibilityElement(accessibilityContainer: self.view!)
    let a11yEltFrame = (myLabel.frame.union(myButton.frame)).union(mySwitch.frame)

    if let elt = elt {

        elt.accessibilityLabel = &quot;regrouping elements&quot;
        elt.accessibilityHint = &quot;double tap to change the switch control status&quot;
        elt.accessibilityFrameInContainerSpace = a11yEltFrame
        elt.accessibilityActivationPoint = mySwitch.center

        self.view.accessibilityElements = [elt]
    }
}


@objc func configChanged(sender: UISwitch){

    if let configGroup = elt {

        let switchValue = (mySwitch?.isOn)! ? &quot;on&quot; : &quot;off&quot;
        configGroup.accessibilityLabel = &quot;the switch control is &quot; + switchValue.description
    }
}</code></pre><p>}
</code></pre></p>
<p>Another grouping elements case could use the <strong>shouldGroupAccessibilityChildren</strong> attribute which is a Boolean that indicates whether <span lang="en">VoiceOver</span> must group its children views.
</br>This allows making unique vocalizations or define a particular reading order for a part of the page <em>(see <a href="#ReadingOrder">Reading order</a> section for further information)</em>.</p>
</div>
<div class="tab-pane" id="groupElts-Links" role="tabpanel" >
- [`accessibilityActivate`](https://developer.apple.com/documentation/objectivec/nsobject/1615165-accessibilityactivate)
- [`shouldGroupAccessibilityChildren`](https://developer.apple.com/documentation/objectivec/nsobject/1615143-shouldgroupaccessibilitychildren)
</div>
</div></br></br>
<a name="ReadingOrder"></a>
<h2 id="reading-order">Reading order</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#readingOrder-Details" 
           role="tab" 
           aria-selected="true">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#readingOrder-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#readingOrder-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="readingOrder-Details"
     role="tabpanel">
Redefining the VoiceOver reading order is done using the **UIAccessibilityContainer** protocol: the idea is to have a table of elements that defines the reading order of the elements.
</br></br>It is often very useful to use the **shouldGroupAccessibilityElement** attribute so we have a precise order but only for a part of the view *(the rest of it will be read using the native order provided by VoiceOver)*.

</div>
<div class="tab-pane" id="readingOrder-Example" role="tabpanel" >
The best way to illustrate this feature is the keyboard whose keys order isn't necessary the appropriate one.
</br>Here's the desired order : 1, 2, 3, 4, 7, 6, 8, 9, 5.
</br></br>Two views are created (blue and grey) and we graphically put the numbers in them as defined hereunder:
</br><img alt="display of the blue and grey views" style="max-width: 500px; height: auto; " src="./images/iOSdev/OrdreDeLecture_1.png" />
<pre><code class="objective-c">
    __weak IBOutlet UIView * blueBlock;
    __weak IBOutlet UIView * greyColumn;

<ul>
<li><p>(void)viewDidAppear:(BOOL)animated {
  [super viewDidAppear:animated];</p>
<p>  //Reads the first three numbers in the grey column.
  greyColumn.shouldGroupAccessibilityChildren = YES;</p>
<p>  //Reads 6, 8, 9 and 5 in this order inside the blue block.
  blueBlock.isAccessibilityElement = NO;
  blueBlock.accessibilityElements = @[key_6,</p>
<pre><code>                                  key_8,
                                  key_9,
                                  key_5];</code></pre><p>}
</code></pre><pre><code class="swift">
  @IBOutlet weak var greyColumn: UIView!
  @IBOutlet weak var blueBlock: UIView!</p>
<p>  override func viewDidAppear(_ animated: Bool) {</p>
<pre><code>  super.viewDidAppear(animated)

  //Reads the first three numbers in the grey column.
  greyColumn.shouldGroupAccessibilityChildren = true

  //Reads 6, 8, 9 and 5 in this order inside the blue block.
  blueBlock.isAccessibilityElement = false
  blueBlock.accessibilityElements = [key_6!,
                                     key_8!,
                                     key_9!,
                                     key_5!]</code></pre><p>  }
</code></pre></p>
</li>
</ul>
</div>
<div class="tab-pane" id="readingOrder-Links" role="tabpanel" >
- [`UIAccessibilityContainer`](https://developer.apple.com/documentation/uikit/accessibility/uiaccessibilitycontainer?language=objc)
- [`shouldGroupAccessibilityChildren`](https://developer.apple.com/documentation/objectivec/nsobject/1615143-shouldgroupaccessibilitychildren)
</div>
</div></br></br>
<h2 id="focus-an-element">Focus an element</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#focusElt-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusElt-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusElt-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusElt-Links" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="focusElt-Description"
     role="tabpanel">
The **UIAccessibilityFocus** informal protocol provides programming elements to be informed of the accessible element focus.

</div>
<div class="tab-pane" id="focusElt-Details" role="tabpanel" >
- **accessibilityElementDidBecomeFocused** : called when the accessible element is focused.
- **accessibilityElementDidLoseFocus** : fired when the accessible element lost focus.
- **accessibilityElementIsFocused** : boolean value indicating the accessible element selection.

<p>Overriden inside a view controller, these elements will be helpless if you think they will be called when an accessible element is focused.
</br>However, if they are <strong>implemented in the accessible element itself</strong>, you won&#39;t be disappointed.
</br></br>This mistake is due to the informal aspect of the protocol that allows an override of its methods inside an inherited NSObject element even if it&#39;s not accessible... like a view controller for instance.</p>
</div>
<div class="tab-pane" id="focusElt-Example" role="tabpanel" >
The example below enables to follow the focus of an accessible element identified by its `accessibleIdentifier`.
<pre><code class="objective-c">
#import "UIView+focus.h"

<p>@implementation UIView (focus)</p>
<ul>
<li><p>(void)accessibilityElementDidBecomeFocused {</p>
<p>  if ([self accessibilityElementIsFocused]) {</p>
<pre><code>  NSLog(@&quot;My element has become focused.&quot;);</code></pre><p>  }
}</p>
</li>
<li><p>(void)accessibilityElementDidLoseFocus {</p>
<p>  if ([self accessibilityElementIsFocused]) {</p>
<pre><code>  NSLog(@&quot;My element has lost focus.&quot;);</code></pre><p>  }
}</p>
</li>
<li><p>(BOOL)accessibilityElementIsFocused {</p>
<p>  if ([self.accessibilityIdentifier isEqualToString:@&quot;myAccessibleElt&quot;]) {</p>
<pre><code>  return YES;</code></pre><p>  } else {</p>
<pre><code>  return NO;</code></pre><p>  }
}
@end
</code></pre><pre><code class="swift">
extension UIView {
  override open func accessibilityElementDidBecomeFocused() {</p>
<pre><code>  if self.accessibilityElementIsFocused() {
      print(&quot;My element has become focused.&quot;)
  }</code></pre><p>  }</p>
<p>  override open func accessibilityElementDidLoseFocus() {</p>
<pre><code>  if self.accessibilityElementIsFocused() {
      print(&quot;My element has lost focus.&quot;)
  }</code></pre><p>  }</p>
<p>  override open func accessibilityElementIsFocused() -> Bool {</p>
<pre><code>  if (self.accessibilityIdentifier == &quot;myAccessibleElt&quot;) {
      return true
  } else {
      return false
  }</code></pre><p>  }
}
</code></pre></p>
</li>
</ul>
</div>
<div class="tab-pane" id="focusElt-Links" role="tabpanel" >
- [`UIAccessibilityFocus`](https://developer.apple.com/documentation/uikit/accessibility/uiaccessibilityfocus)
</div>
</div></br></br>
<h2 id="modify-the-focus-area-of-voiceover">Modify the focus area of VoiceOver</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#focusArea-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusArea-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusArea-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#focusArea-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="focusArea-Description"
     role="tabpanel">
In the case of dynamically modified element or component not inheriting from `UIView`, it is possible to modify the focus area of accessibility of this element, i.e. the area <span lang="en">VoiceOver</span> highlights when focusing an element.

</div>
<div class="tab-pane" id="focusArea-Details" role="tabpanel" >
- **accessibilityFrame**&nbsp;: sets the area via a rectangle (`CGRect`).
</br>Usually, for an element inheriting from `UIView`, this area is the «&nbsp;visible&nbsp;» part of the view.
- **accessibilityPath**&nbsp;: equivalent to `accessibilityFrame` but sets the area via Bezier curves.
<a name="AccessibilityActivationPoint"></a>
- **accessibilityActivationPoint**&nbsp;: defines a contact point inside the `frame` whose action will be fired by a double-tap element activation.
</br>The default value is the midpoint of the `frame` but it can be redefine anywhere inside.
</br>A classical use case could be an easy activation inside a [regroupment of elements](#ActivationPointExemple) for instance.
</br><img alt="" style="max-width: 350px; height: auto; " src="./images/iOSdev/ModifierLaZoneDeFocus_2.png" />
</br>By keeping this default value, one might unwillingly activate the element in the middle of the frame only by activating the created regroupment.

</div>
<div class="tab-pane" id="focusArea-Example" role="tabpanel" >
<img alt="" style="max-width: 700px; height: auto; " src="./images/iOSdev/ModifierLaZoneDeFocus_1.png" />
<pre><code class="objective-c">
float xVal;
float yVal;
float widthVal;
float heightVal;

<ul>
<li><p>(void)viewDidAppear:(BOOL)animated {
  [super viewDidAppear:animated];</p>
<p>  xVal = myLabel.accessibilityFrame.origin.x;
  yVal = myLabel.accessibilityFrame.origin.y;
  widthVal = myLabel.accessibilityFrame.size.width;
  heightVal = myLabel.accessibilityFrame.size.height;</p>
</li>
</ul>
<p>}</p>
<p>//First way to enlarge the focus area.</p>
<ul>
<li><p>(IBAction)tapHere:(UIButton *)sender {</p>
<p>  myLabel.accessibilityFrame = CGRectMake(xVal,</p>
<pre><code>                                      yVal,
                                      widthVal + 100.0,
                                      heightVal+ 100.0);</code></pre><p>  UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);
}</p>
</li>
</ul>
<p>//Second way to enlarge the focus area (Bezier).</p>
<ul>
<li><p>(IBAction)clic:(UIButton *)sender {</p>
<p>  UIBezierPath * bezierPath = [UIBezierPath bezierPath];</p>
<p>  [bezierPath moveToPoint:CGPointMake(xVal, yVal)];</p>
<p>  [bezierPath addLineToPoint:CGPointMake(xVal + widthVal + 100.0, </p>
<pre><code>                                     yVal)];</code></pre><p>  [bezierPath addLineToPoint:CGPointMake(xVal + widthVal + 100.0, </p>
<pre><code>                                     yVal + heightVal+ 100.0)];</code></pre><p>  [bezierPath addLineToPoint:CGPointMake(xVal, </p>
<pre><code>                                     yVal + heightVal+ 100.0)];</code></pre><p>  [bezierPath closePath];</p>
<p>  myLabel.accessibilityPath = bezierPath;</p>
<p>  UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);
}
</code></pre><pre><code class="swift">
  var xVal: CGFloat = 0.0
  var yVal: CGFloat = 0.0
  var widthVal: CGFloat = 0.0
  var heightVal: CGFloat = 0.0</p>
<p>  override func viewDidAppear(_ animated: Bool) {</p>
<pre><code>  super.viewDidAppear(animated)

  xVal = myLabel.accessibilityFrame.origin.x;
  yVal = myLabel.accessibilityFrame.origin.y;
  widthVal = myLabel.accessibilityFrame.size.width;
  heightVal = myLabel.accessibilityFrame.size.height;</code></pre><p>  }</p>
<p>  //First way to enlarge the focus area.
  @IBAction func clicHere(_ sender: UIButton) {</p>
<pre><code>  myLabel.accessibilityFrame = CGRect.init(x: xVal,
                                           y: yVal,
                                           width: widthVal + 100.0,
                                           height: heightVal + 100.0)

  UIAccessibility.post(notification: UIAccessibility.Notification.layoutChanged,
                       argument: myLabel)</code></pre><p>  }</p>
<p>  //Second way to enlarge the focus area (Bezier).
  @IBAction func clic(_ sender: UIButton) {</p>
<pre><code>  let bezierPath = UIBezierPath.init()

  bezierPath.move(to: CGPoint.init(x: xVal, y: yVal))

  bezierPath.addLine(to: CGPoint.init(x: xVal + widthVal + 100.0,
                                      y: yVal))
  bezierPath.addLine(to: CGPoint.init(x: xVal + widthVal + 100.0,
                                      y: yVal + heightVal + 100.0))
  bezierPath.addLine(to: CGPoint.init(x: xVal,
                                      y: yVal + heightVal + 100.0))
  bezierPath.close()

  myLabel.accessibilityPath = bezierPath

  UIAccessibility.post(notification: UIAccessibility.Notification.screenChanged,
                       argument: myLabel)</code></pre><p>  }
</code></pre></p>
</li>
</ul>
</div>
<div class="tab-pane" id="focusArea-Links" role="tabpanel" >
- [`accessibilityFrame`](https://developer.apple.com/documentation/uikit/uiaccessibilityelement/1619579-accessibilityframe)
- [`accessibilityPath`](https://developer.apple.com/documentation/objectivec/nsobject/1615159-accessibilitypath)
- [`accessibilityActivationPoint`](https://developer.apple.com/documentation/objectivec/nsobject/1615179-accessibilityactivationpoint)
</div>
</div></br></br>
<h2 id="text-size">Text size</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#textSize-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#textSize-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#textSize-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="textSize-Description"
     role="tabpanel">
Since iOS7, it is possible to make the text size dynamic according to the phone settings.

</div>
<div class="tab-pane" id="textSize-Details" role="tabpanel" >
<img alt="larger accessibility sizes option screenshot" style="max-width: 700px; height: auto; " src="./images/iOSdev/TailleDesTextes_1.png" />
</br>The following steps should be respected in order to easily use this <abbr>API</abbr>&nbsp;:
 - **Use the text styles** available with the application iOS version.
 </br><img alt="" style="max-width: 400px; height: auto; " src="./images/iOSdev/TailleDesTextes_2.png" />
 - Choose the system font to facilitate your programing even if the use of other fonts is well assisted by the `UIFontMetrics` new class (iOS11).
 <pre><code class="objective-c">
    __weak IBOutlet UILabel * fontHeadline;
    __weak IBOutlet UILabel * fontFootNote;

<pre><code>//Use of the default native font.
fontFootNote.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline];

//Customed font definition for a header.
UIFont * fontHead = [UIFont fontWithName:@&quot;Chalkduster&quot; size:30.0];
UIFontMetrics * fontHeadMetrics = [[UIFontMetrics alloc]initForTextStyle:UIFontTextStyleHeadline];
fontHeadline.font = [fontHeadMetrics scaledFontForFont:fontHead];</code></pre><p></code></pre><pre><code class="swift">
    @IBOutlet weak var fontHeadline: UILabel!
    @IBOutlet weak var fontFootNote: UILabel!</p>
<pre><code>//Use of the default native font for a header.
fontFootNote.font = .preferredFont(forTextStyle: .headline)

//Customed font definition for a header.
let fontHead = UIFont(name: &quot;Chalkduster&quot;, size: 30.0)
let fontHeadMetrics = UIFontMetrics(forTextStyle: .headline)
fontHeadline.font = fontHeadMetrics.scaledFont(for: fontHead!)</code></pre><p></code></pre></p>
<ul>
<li><p>Listen to the font size settings change event <strong>UIContentSizeCategoryDidChange</strong> or directly use the property <strong>adjustsFontForContentSizeCategory</strong> to have an automatic update of your system font size if you&#39;re programming in iOS10 (this attribute applies to custom fonts only with the <code>UIFontMetrics</code> class).
</br>Note that the <strong>traitCollectionDidChange</strong> method that belongs to the <code>UITraitEnvironment</code> informal protocol may also be used in this context because it will be called as soon as the iOS interface environment changes <em>(class/content size, portrait/landscape)</em>.</p>
<pre><code class="objective-c">
 //Listens to the notification dealing with the font size changing from the mobile settings.
 [[NSNotificationCenter defaultCenter] addObserver:self
                                          selector:@selector(methodToBeCalled:)
                                              name:UIContentSizeCategoryDidChangeNotification
                                            object:nil];

 //Automatic changing of the font size without listening to the previous notification.
 fontHeadline.adjustsFontForContentSizeCategory = YES;

 - (void)methodToBeCalled:(NSNotification *)notification {

     //When handling the font size change event, you must redisplay the affected elements.
     fontFootNote.font = [UIFont preferredFontForTextStyle:UIFontTextStyleFootnote];
 }
</code></pre><pre><code class="swift">
<p> //Listens to the notification dealing with the font size changing from the mobile settings.
 NotificationCenter.default.addObserver(self,</p>
<pre><code>                                    selector:#selector(methodToBeCalled(notification:)),
                                    name: UIContentSizeCategory.didChangeNotification,
                                    object: nil)</code></pre><p> //Automatic changing of the font size without listening to the previous notification.
 fontHeadline.adjustsFontForContentSizeCategory = true</p>
<p> @objc func methodToBeCalled(notification: Notification) {</p>
<pre><code> //When handling the font size change event, you must redisplay the affected elements.
 fontFootNote.font = UIFont.preferredFont(forTextStyle: .footnote)</code></pre><p> }
</code></pre></p>
</li>
<li><p>Be careful that the containers fit their contents: using constraints is the best way to perform this task using dynamic values.</p>
</li>
<li><p>Don&#39;t forget to adapt the <a href="./criteria-ios.html#colours">color contrast</a> to the text size.</p>
</li>
</ul>
</div>
<div class="tab-pane" id="textSize-Links" role="tabpanel" >
- [Dynamic Type & Text Styles](https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/typography/)
- [`UIContentSizeCategoryDidChange`](https://developer.apple.com/documentation/foundation/nsnotification.name/1622948-uicontentsizecategorydidchange)
- [`adjustsFontForContentSizeCategory`](https://developer.apple.com/documentation/uikit/uicontentsizecategoryadjusting/1771731-adjustsfontforcontentsizecategor?language=objc)

</div>
</div></br></br>
<h2 id="truncation-hyphen">Truncation hyphen</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#truncHyphen-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#truncHyphen-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="truncHyphen-Description"
     role="tabpanel">
The `Dynamic Type` feature introduced in the previous section may come along with a word truncation according to the magnifying that is defined in the settings.
</br>Unfortunately, the iOS system doesn't handle natively this point that can be implemented only by programing to get an appreciated visual depiction.

</div>
<div class="tab-pane" id="truncHyphen-Example" role="tabpanel" >
<img alt="" style="max-width: 700px; height: auto; " src="./images/iOSdev/Troncature.png" />
</br>The rationale behind is the use of a `NSMutableAttributedString` with a `NSMutableParagraphStyle` type property as exposed hereunder:

<pre><code class="objective-c">
@interface TruncationHyphen () {
    __weak IBOutlet UILabel * myLabel;
}
@end


@implementation TruncationHyphen

- (void)viewDidLoad {
    [super viewDidLoad];

    NSString * myString = @"floccinaucinihilipilification";
    NSMutableParagraphStyle * paraph = [[NSMutableParagraphStyle alloc] init];

    paraph.alignment = NSTextAlignmentJustified;
    paraph.hyphenationFactor = 1.0;

    UIFont * myFont = [UIFont fontWithName:@"HoeflerText-Black" size:18.0];
    UIFont * myTextFont = [[UIFontMetrics metricsForTextStyle:UIFontTextStyleTitle1] scaledFontForFont:myFont];

    NSDictionary * attributesDictionary = @{NSFontAttributeName:myTextFont};
    NSMutableAttributedString * myText = [[NSMutableAttributedString alloc]initWithString:myString 
                                                                               attributes:attributesDictionary];

    [myText addAttribute:NSParagraphStyleAttributeName
                   value:paraph
                   range:NSMakeRange(0, 1)];

    myLabel.attributedText = myText;
}
@end
</code></pre><pre><code class="swift">
<p>class TruncationHyphen: UIViewController {</p>
<pre><code>@IBOutlet weak var myLabel: UILabel!

override func viewDidLoad() {
    super.viewDidLoad()

    let myString = &quot;floccinaucinihilipilification&quot;

    let paraph = NSMutableParagraphStyle()
    paraph.alignment = .justified
    paraph.hyphenationFactor = 1.0

    let myTextFont = UIFontMetrics(forTextStyle: .title1).scaledFont(for:UIFont(name:&quot;HoeflerText-Black&quot;, size:18)!)

    let myText = NSMutableAttributedString(string:myString,
                                           attributes: [.font: myTextFont])

    myText.addAttribute(.paragraphStyle,
                        value: paraph,
                        range: NSMakeRange(0,1))

    myLabel.attributedText = myText
}</code></pre><p>}
</code></pre></p>
</div>
</div></br></br>
<h2 id="graphical-elements-size">Graphical elements size</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#graphEltSize-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#graphEltSize-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#graphEltSize-Links" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="graphEltSize-Description"
     role="tabpanel">
Exactly like text, images and tab/tool bar items have a scalable size thanks to accessibility settings but **only since iOS11 with Xcode 9**.

</div>
<div class="tab-pane" id="graphEltSize-Example" role="tabpanel" >
To illustrate these new features, the example below is obtained by following the steps hereafter:
</br></br>1. Under Xcode, import the image to be enlarged with a `pdf` extension and a x1 resolution in the `xcassets` catalog.
</br></br>2. In the new Image Set, tick `Preserve Vector Data` and specify `Single Scale` as Scales attribute &nbsp;:
</br><img alt="" style="max-width: 700px; height: auto; " src="./images/iOSdev/TailleDesEltsGraphiques_4.png" />
</br></br>3. If a storyboard is used for this image, tick `Adjusts Image Size` in the Image View section, otherwise put the `adjustsImageSizeForAccessibilityContentSizeCategory` image property to `true` in code &nbsp;:
</br><img alt="" style="max-width: 350px; height: auto; " src="./images/iOSdev/TailleDesEltsGraphiques_5.png" />
</br></br>4. If a **tab bar** or a **tool bar** is used in the application, first repeat the previous 3 steps for each image included in the items to be enlarged in the middle of the screen and then link the image to its appropriate item &nbsp;:
</br><img alt="" style="max-width: 350px; height: auto; " src="./images/iOSdev/TailleDesEltsGraphiques_6.png" />
</br>**WARNING : don't forget to check out your layout with these new images larger sizes.**
</br></br>An application with a tab bar, whose second bar item displays the Orange logo (added `Aspect Fit` content mode and constraints to stretch the image view), is created to test the features exposed in the description.
</br></br>With the `Larger Accessibility Sizes` activation in the settings (see <a href="http://a11y-guidelines.orange.com/mobile_EN/dev-ios.html#graphical-elements-size">the previous section</a>), one can easily note in the application &nbsp;:
- A larger Orange image size.
- A larger version of the bar item in an overlay if you touch and hold over it.
</br><img alt="" style="max-width: 1050px; height: auto; " src="./images/iOSdev/TailleDesEltsGraphiques_10.png" />

</div>
<div class="tab-pane" id="graphEltSize-Links" role="tabpanel" >
- [`adjustsImageSizeForAccessibilityContentSizeCategory`](https://developer.apple.com/documentation/uikit/uiaccessibilitycontentsizecategoryimageadjusting/2890929-adjustsimagesizeforaccessibility)
</div>
</div></br></br>
<h2 id="continuous-adjustable-values">Continuous adjustable values</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#adjustable-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#adjustable-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#adjustable-Links" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="adjustable-Description"
     role="tabpanel">
Graphics like `picker`, `stepper` or `slider` have the ability to continuously change the value they provide.
</br><img alt="picker, stepper and slider screenshot" style="max-width: 700px; height: auto; " src="./images/iOSdev/ValeursAjustables_1.png" />
</br>It's hard to render what's happening when the changing isn't graphically or vocally notified.

</div>
<div class="tab-pane" id="adjustable-Example" role="tabpanel" >
The following methodology to resolve this problem for blind people using VoiceOver may be the same for these three graphics, that's why only the `stepper` will be handled.
</br></br>Creating a `stepper` with a `label` to display its value provides the following rendering :
</br><img alt="stepper is vocalize like 3 differents objects" style="max-width: 900px; height: auto; " src="./images/iOSdev/ValeursAjustables_2.png" />
</br>The focus must change to :
- Get each element that increases or decreases the value.
- Know the value provided by the `label`.

<p>Moreover, there is no real time notification dealing with the value changing.
</br>Nothing is definitely blocking in use but these latest remarks lead to a new design for this example that used to be so simple.
</br></br>The rationale behind is to be able to change the <code>stepper</code> value, to be informed of this modification and to know the new value thanks to a single and unique object.
</br><strong>Group the <code>stepper</code>and the <code>label</code></strong> <em>(a StackView should do the job)</em> then put <strong><code>UIAccessibilityTraitAdjustable</code></strong> as a new trait for this new accessible group.
</br>This <code>trait</code> is <strong>MANDATORY</strong> linked to the <code>accessibilityIncrement()</code> and <code>accessibilityDecrement()</code> methods that must be implemented to define the continous way of changing the value.
</br></br>As a result, all the previous constraints are removed and a <code>hint</code> is natively provided by this <code>trait</code> to mention the proper way of using this object.
</br><img alt="stepper is well vocalized" style="max-width: 1000px; height: auto; " src="./images/iOSdev/ValeursAjustables_4.png" /></p>
<ul>
<li>To get this result, the container class {<code>stepper</code> + <code>label</code>} is first created to allow the delegation for the future value changing.</li>
</ul>
<pre><code class="objective-c">
-===== StepperWrapper.h =====-
NS_ASSUME_NONNULL_BEGIN
@class StepperWrapper;

@protocol AdjustableForAccessibilityDelegate &lt;NSObject&gt;
- (void)adjustableDecrementForView:(StepperWrapper *)view;
- (void)adjustableIncrementForView:(StepperWrapper *)view;
@end


@interface StepperWrapper : UIStackView
@property(nonatomic,weak) id &lt;AdjustableForAccessibilityDelegate&gt; delegate;
@end
NS_ASSUME_NONNULL_END


-===== StepperWrapper.m =====-
NS_ASSUME_NONNULL_BEGIN
@implementation StepperWrapper

- (instancetype)initWithCoder:(NSCoder *)coder {

    self = [super initWithCoder:coder];

    self.isAccessibilityElement = YES;
    self.accessibilityTraits = UIAccessibilityTraitAdjustable;

    return self;
}

- (void)accessibilityDecrement {
    if ([_delegate respondsToSelector:@selector(adjustableDecrementForView:)]) {
        [_delegate adjustableDecrementForView:self];
    }
}

- (void)accessibilityIncrement {
    if ([_delegate respondsToSelector:@selector(adjustableIncrementForView:)]) {
        [_delegate adjustableIncrementForView:self];
    }
}
</code></pre><pre><code class="swift">
<p>protocol AdjustableForAccessibilityDelegate: class {
    func adjustableDecrementFor(_ view: StepperWrapper)
    func adjustableIncrementFor(_ view: StepperWrapper)
}</p>
<p>class StepperWrapper: UIStackView {</p>
<pre><code>weak var delegate: AdjustableForAccessibilityDelegate?

override init(frame: CGRect) {
    super.init(frame: frame)
}

required init(coder: NSCoder) {
    super.init(coder: coder)

    isAccessibilityElement = true
    accessibilityTraits = .adjustable
}

override func accessibilityDecrement() {
    delegate?.adjustableDecrementFor(self)
}

override func accessibilityIncrement() {
    delegate?.adjustableIncrementFor(self)
}</code></pre><p>}
</code></pre></p>
<ul>
<li>Next, the two methods of the implemented protocol must be defined before updating and vocally presenting the new value in the ViewController.</li>
</ul>
<pre><code class="objective-c">
NS_ASSUME_NONNULL_BEGIN
@interface ContinuousAdjustableValues () &lt;AdjustableForAccessibilityDelegate&gt;
@property (weak, nonatomic) IBOutlet StepperWrapper * stepperStackViewAccess;
@property (weak, nonatomic) IBOutlet UIStepper * stepperAccess;
@property (weak, nonatomic) IBOutlet UILabel * stepperValueAccess;
@end


@implementation ContinuousAdjustableValues
- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];

    _stepperStackViewAccess.delegate = self;
    _stepperStackViewAccess.accessibilityLabel = @"increase or decrease the value";
    _stepperStackViewAccess.accessibilityValue = _stepperValueAccess.text;
}

- (void)adjustableDecrementForView:(StepperWrapper *)view {
    _stepperAccess.value  -= _stepperAccess.stepValue;
    [self updateStepperValue];
}

- (void)adjustableIncrementForView:(StepperWrapper *)view {
    _stepperAccess.value  += _stepperAccess.stepValue;
    [self updateStepperValue];
}

- (void) updateStepperValue {
    _stepperValueAccess.text = [NSString stringWithFormat:@"Value = %0.1f",_stepperAccess.value];
    _stepperStackViewAccess.accessibilityValue = _stepperValueAccess.text;
}
@end
NS_ASSUME_NONNULL_END
</code></pre><pre><code class="swift">
<p>class ContinuousAdjustableValues: UIViewController, AdjustableForAccessibilityDelegate {</p>
<pre><code>@IBOutlet weak var stepperStackViewAccess: StepperWrapper!
@IBOutlet weak var stepperAccess: UIStepper!
@IBOutlet weak var stepperValueAccess: UILabel!


override func viewDidLoad() {
    super.viewDidLoad()

    stepperStackViewAccess.delegate = self
    stepperStackViewAccess.accessibilityLabel = &quot;increase or decrease the value&quot;
    stepperStackViewAccess.accessibilityValue = stepperValueAccess.text
}

func adjustableDecrementFor(_ view: StepperWrapper) {
    stepperAccess.value -= stepperAccess.stepValue
    updateStepperValue()
}

func adjustableIncrementFor(_ view: StepperWrapper) {
    stepperAccess.value += stepperAccess.stepValue
    updateStepperValue()
}

private func updateStepperValue() {
    stepperValueAccess.text = &quot;Value = \(stepperAccess.value)&quot;
    stepperStackViewAccess.accessibilityValue = stepperValueAccess.text
}</code></pre><p>}
</code></pre></p>
</div>
<div class="tab-pane" id="adjustable-Links" role="tabpanel" >
- [`UIAccessibilityTraitAdjustable`](https://developer.apple.com/documentation/uikit/uiaccessibilitytraitadjustable)
</div>
</div></br></br>
<h2 id="custom-actions">Custom actions</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#customActions-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#customActions-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#customActions-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="customActions-Description"
     role="tabpanel">
Some basic gestures may become a real headache to be perfectly understood by VoiceOver in a fluent way for the user.
</br>A convincing example is the iOS native mail that may suggest some actions as follows :
</br><img alt="flick left to display actions without VoiceOver" style="max-width: 900px; height: auto; " src="./images/iOSdev/Actions_1.png" />
</br>This gesture cannot lead to the proper result with VoiceOver because a flick left will give rise to the selection of the previous accessible element instead of suggesting actions as above.

</div>
<div class="tab-pane" id="customActions-Example" role="tabpanel" >
A solution may consist of **associating the selected element with an array of actions** that will be automatically introduced to the user.
</br><img alt="" style="max-width: 900px; height: auto; " src="./images/iOSdev/Actions_2.png" />

<pre><code class="objective-c">
@interface CustomActions ()
@property (weak, nonatomic) IBOutlet UILabel * persoElt;
@end


@implementation CustomActions
- (void)viewDidLoad {
    [super viewDidLoad];

    UIAccessibilityCustomAction * a11yMoreAction = [[UIAccessibilityCustomAction alloc]initWithName:@"more"
                                                                                             target:self
                                                                                           selector:@selector(moreAction)];
    UIAccessibilityCustomAction * a11yFlagAction = [[UIAccessibilityCustomAction alloc]initWithName:@"flag"
                                                                                             target:self
                                                                                           selector:@selector(flagAction)];
    UIAccessibilityCustomAction * a11yDeleteAction = [[UIAccessibilityCustomAction alloc]initWithName:@"delete"
                                                                                               target:self
                                                                                             selector:@selector(deleteAction)];

    _persoElt.accessibilityCustomActions = @[a11yMoreAction,
                                             a11yFlagAction,
                                             a11yDeleteAction];
}

- (BOOL)moreAction {
    //Code to be implemented for the appropriate action.
    return YES;
}

- (BOOL)flagAction {
    //Code to be implemented for the appropriate action.
    return YES;
}

- (BOOL)deleteAction {
    //Code to be implemented for the appropriate action.
    return YES;
}
@end
</code></pre><pre><code class="swift">
<p>class CustomActions: UIViewController {</p>
<pre><code>@IBOutlet weak var persoElt: UILabel!


override func viewDidLoad() {
    super.viewDidLoad()

    let a11yMoreAction = UIAccessibilityCustomAction(name: &quot;more&quot;,
                                                     target: self,
                                                     selector: #selector(moreAction))

    let a11yFlagAction = UIAccessibilityCustomAction(name: &quot;flag&quot;,
                                                     target: self,
                                                     selector: #selector(flagAction))

    let a11yDeleteAction = UIAccessibilityCustomAction(name: &quot;delete&quot;,
                                                       target: self,
                                                       selector: #selector(deleteAction))

    persoElt.accessibilityCustomActions = [a11yMoreAction,
                                           a11yFlagAction,
                                           a11yDeleteAction]
}


@objc func moreAction() -&gt; Bool {
    //Code to be implemented for the appropriate action.
    return true
}

@objc func flagAction() -&gt; Bool {
    //Code to be implemented for the appropriate action.
    return true
}

@objc func deleteAction() -&gt; Bool {
    //Code to be implemented for the appropriate action.
    return true
}</code></pre><p>}
</code></pre></p>
<p></br>The code above gives rise to the following result thanks to consecutive flicks on the selected accessible element :
</br><img alt="flick up to vocalize suggesterd actions with VoiceOver activated" style="max-width: 900px; height: auto; " src="./images/iOSdev/Actions_3.png" /></p>
</div>
<div class="tab-pane" id="customActions-Links" role="tabpanel" >
- [`accessibilityCustomActions`](https://developer.apple.com/documentation/objectivec/nsobject/1615150-accessibilitycustomactions)
- [`UIAccessibilityCustomAction`](https://developer.apple.com/documentation/uikit/uiaccessibilitycustomaction)
</div>
</div></br></br>
<h2 id="custom-rotor">Custom rotor</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#rotor-Details" 
           role="tab" 
           aria-selected="true">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#rotor-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#rotor-Link" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="rotor-Details"
     role="tabpanel">
Since iOS10, adding a new rotor option is possible thanks to the **UIAccessibilityCustomRotor** whose creation is based on 2 elements :
- **UIAccessibilityCustomRotorSearchPredicate** : defines the logic according to the flick type on the screen.
- **UIAccessibilityCustomRotorItemResult** : ensued element from the logic above.

<img alt="" style="max-width: 500px; height: auto; " src="./images/iOSdev/CustomRotor_1.png" />

</div>
<div class="tab-pane" id="rotor-Example" role="tabpanel" >
    To illustrate the programing side of this feature, the code snippet below counts and displays all the flicks up and down.
<pre><code class="objective-c">
@interface CustomRotor ()
@property (weak, nonatomic) IBOutlet UILabel * rotorTitle;
@property (weak, nonatomic) IBOutlet UILabel * upLabel;
@property (weak, nonatomic) IBOutlet UILabel * downLabel;
@end


<p>@implementation CustomRotor</p>
<p>static NSInteger flicksUp;
static NSInteger flicksDown;</p>
<ul>
<li><p>(void)initialize {</p>
<p>  flicksUp = 0;
  flicksDown = 0;
}</p>
</li>
</ul>
<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>
<p>  UIAccessibilityCustomRotor * rotor = [self buildMyRotor:@&quot;Rotor info&quot;];
  self.accessibilityCustomRotors = @[rotor];
}</p>
</li>
</ul>
<ul>
<li><p>(UIAccessibilityCustomRotor *)buildMyRotor:(NSString * _Nonnull)name{</p>
<p>  return [[UIAccessibilityCustomRotor alloc]initWithName:name</p>
<pre><code>                                     itemSearchBlock:^UIAccessibilityCustomRotorItemResult * _Nullable(UIAccessibilityCustomRotorSearchPredicate * _Nonnull predicate) {

                                         if (predicate.searchDirection == UIAccessibilityCustomRotorDirectionNext) {

                                             flicksDown += 1;
                                             self.downLabel.text = [NSString stringWithFormat:@&quot;%ld&quot;,(long)flicksDown];

                                         } else {

                                             flicksUp += 1;
                                             self.upLabel.text = [NSString stringWithFormat:@&quot;%ld&quot;,(long)flicksUp];
                                         }

                                         return [[UIAccessibilityCustomRotorItemResult alloc] initWithTargetElement:self.rotorTitle
                                                                                                        targetRange:nil];
                                     }];</code></pre><p>}
@end
</code></pre><pre><code class="swift">
class CustomRotor: UIViewController {</p>
<p>  @IBOutlet weak var rotorTitle: UILabel!</p>
<p>  static var flicksUp = 0
  @IBOutlet weak var upLabel: UILabel!</p>
<p>  static var flicksDown = 0
  @IBOutlet weak var downLabel: UILabel!</p>
</li>
</ul>
<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    let rotor = buildMyRotor(&quot;Rotor info&quot;)
    self.accessibilityCustomRotors = [rotor]
}


func buildMyRotor(_ name: String) -&gt; UIAccessibilityCustomRotor {

    return  UIAccessibilityCustomRotor.init(name: name,
                                            itemSearch: { predicate -&gt; UIAccessibilityCustomRotorItemResult? in

                                                if (predicate.searchDirection == UIAccessibilityCustomRotor.Direction.next) {

                                                    CustomRotor.flicksDown += 1
                                                    self.downLabel.text = String(CustomRotor.flicksDown)

                                                } else {

                                                    CustomRotor.flicksUp += 1
                                                    self.upLabel.text = String(CustomRotor.flicksUp)
                                                }

                                                return UIAccessibilityCustomRotorItemResult.init(targetElement:self.rotorTitle,
                                                                                                 targetRange: nil)
    })
}</code></pre><p>}
</code></pre></p>
<p></br>The code above gives rise to the following illustrated steps :
</br><img alt="changed display with a rotor option" style="max-width: 1100px; height: auto; " src="./images/iOSdev/CustomRotor_2.png" />
</br>The use of a custom rotor is definitely not a natural part of a mobile application, that&#39;s why its <strong>functioning</strong> and <strong>purpose</strong> must be <strong>fully explained</strong> to assist the user experience.
</br></br>The main difference between a rotor option and a custom action or an adjustable element relies on the fact that it can be activated whatever the selected element.
</br>However, if the selected element is adjustable or holds any custom actions, <strong>its actions will prevail over those of the rotor</strong>.
</br></br>Such a feature must be implemented with <strong>caution</strong> and according to <strong>specific needs</strong> whose only purpose should be to <strong>improve and facilitate the user experience</strong>.</p>
</div>
<div class="tab-pane" id="rotor-Link" role="tabpanel" >
- [`UIAccessibilityCustomRotor`](https://developer.apple.com/documentation/uikit/uiaccessibilitycustomrotor)
- [`UIAccessibilityCustomRotorItemResult`](https://developer.apple.com/documentation/uikit/uiaccessibilitycustomrotoritemresult)
- [`UIAccessibilityCustomRotorSearchPredicate`](https://developer.apple.com/documentation/uikit/uiaccessibilitycustomrotorsearchpredicate)
</div>
</div></br></br>
<h2 id="accessibility-options">Accessibility options</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#a11yOptions-States" 
           role="tab" 
           aria-selected="true">States</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#a11yOptions-Events" 
           role="tab" 
           aria-selected="false">Events</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#a11yOptions-Recap" 
           role="tab" 
           aria-selected="false">Recap</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#a11yOptions-Link" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="a11yOptions-States"
     role="tabpanel">
On iOS, it is possible to check the accessibility options state. 
</br>Is VoiceOver activated? Is the audio-mono mode activated? Several methods that are part of the `UIKit` framework can help you to check with that.
</br>The most useful method is **UIAccessibilityIsVoiceOverRunning** which allows to know whether VoiceOver is activated.
</br></br>Some other methods are deeply explained in a <a href="./dev-ios-wwdc-18230.html" style="text-decoration: underline;">WWDC 2018 video</a> *(Deliver en exceptional accessibility experience)* whose content is perfectly detailed in the iOS WWDC section of this site.</br></br>

<pre><code class="objective-c">
    BOOL isVoiveOverRunning = (UIAccessibilityIsVoiceOverRunning() ? 1 : 0);
    BOOL isSwitchControlRunning = (UIAccessibilityIsSwitchControlRunning() ? 1 : 0);

    NSLog(@"VoiceOver is %d and SwitchControl is %d.", isVoiveOverRunning, isSwitchControlRunning);
</code></pre><pre><code class="swift">
<pre><code>let isVoiceOverRunning = (UIAccessibility.isVoiceOverRunning ? 1 : 0)
let isSwitchControlRunning = (UIAccessibility.isSwitchControlRunning ? 1 : 0)

print(&quot;VoiceOver is \(isVoiceOverRunning) and SwichControl is \(isSwitchControlRunning).&quot;)</code></pre><p></code></pre></p>
</div>
<div class="tab-pane" id="a11yOptions-Events" role="tabpanel" >
iOS sends many accessibility events when accessibility options have changed.
</br></br>For example, if VoiceOver is deactivated, the running applications will receive the `UIAccessibilityVoiceOverStatusDidChangeNotification` event.
</br>This is very useful when used simultaneously with `UIAccessibilityIsVoiceOverRunning`.
</br></br>Let's say the application behaves differently when VoiceOver is turned on.
</br>What happens if VoiceOver is disabled ? This is exactly the use case when the system events can be used.
</br>By listening to these events, it is possible to dynamically change how the application behaves.</br></br>

<p>In this example, a method is fired when VoiceOver or Switch Control status has changed.</p>
<pre><code class="objective-c">
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(methodToBeCalled:)
                                                 name:UIAccessibilitySwitchControlStatusDidChangeNotification
                                               object:nil];

    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(methodToBeCalled:)
                                                 name:UIAccessibilityVoiceOverStatusDidChangeNotification
                                               object:nil];
}

- (void)methodToBeCalled:(NSNotification *)notification {

    NSArray * checkStatus = @[@"NOK", @"OK"];

    NSLog(@"SWITCH CONTROL is %@ and VOICE OVER is %@",
          checkStatus[UIAccessibilityIsSwitchControlRunning()],
          checkStatus[UIAccessibilityIsVoiceOverRunning()]);
}
</code></pre><pre><code class="swift">
<pre><code>override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    NotificationCenter.default.addObserver(self,
                                           selector: #selector(methodToBeCalled(notification:)),
                                           name: UIAccessibility.switchControlStatusDidChangeNotification,
                                           object: nil)

    NotificationCenter.default.addObserver(self,
                                           selector: #selector(methodToBeCalled(notification:)),
                                           name: UIAccessibility.voiceOverStatusDidChangeNotification,
                                           object: nil)
}

@objc private func methodToBeCalled(notification: Notification) {

    let switchControlStatus = (UIAccessibility.isSwitchControlRunning ? &quot;OK&quot; : &quot;NOK&quot;)
    let voiceOverStatus = (UIAccessibility.isVoiceOverRunning ? &quot;OK&quot; : &quot;NOK&quot;)

    print(&quot;SWITCH CONTROL is \(switchControlStatus) and VOICE OVER is \(voiceOverStatus).&quot;)
}</code></pre><p></code></pre></p>
</div>
<div class="tab-pane" id="a11yOptions-Recap" role="tabpanel" >
All accessibility <a href="https://developer.apple.com/documentation/uikit/accessibility/notification_names?language=objc" style="text-decoration: underline;">events</a> and <a href="https://developer.apple.com/documentation/uikit/accessibility?language=objc" style="text-decoration: underline;">options</a> are available on the official documentation from Apple.
</br><img alt="" style="max-width: 1100px; height: auto; " src="./images/iOSdev/OptionsA11Y.png" />
</div>
<div class="tab-pane" id="a11yOptions-Link" role="tabpanel" >
- [Accessibility options](./criteria-ios.html#accessibility-options) *(iOS conception)*
</div>
</div></br></br>
<h2 id="navigation-bar">Navigation bar</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#navBar-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#navBar-LeftBarItem" 
           role="tab" 
           aria-selected="false">LeftBarItem</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#navBar-Title" 
           role="tab" 
           aria-selected="false">Title</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#navBar-RightBarItem" 
           role="tab" 
           aria-selected="false">RightBarItem</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#navBar-ReadingOrder" 
           role="tab" 
           aria-selected="false">Reading order</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#navBar-Link" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="navBar-Description"
     role="tabpanel">
Using a navigation bar is a common practice that can be divided into three main parts:
</br></br><img alt="" style="max-width: 500px; height: auto; " src="./images/iOSdev/NavigationBar_1.png" />

<ul>
<li><strong>LeftBarItem</strong> : usually includes only a single element to get back to the previous screen.</li>
<li><strong>Title</strong> : often presented as a simple text that may be build with StackViews in the most complex use cases.</li>
<li><strong>RightBarItem</strong> : area  that might contains many different icons <em>(account, authentication, validation...)</em>.</li>
</ul>
<p>Using the standard components with few navigation bar customizations is a good way to give rise to the best VoiceOver result with minimal effort.
</br></br>Unfortunately, some project constraints may prevent such a practice: specific examples are then provided hereunder so as to ease some delicate implementations that might include the reading order of items comprising even those of the navigation bar.</p>
</div>
<div class="tab-pane" id="navBar-LeftBarItem" role="tabpanel" >

<p>Once the navigation bar loaded, a new <code>label</code> must be provided so as to amend only the VoiceOver reading out without modifying the appearance of the left bar item.</p>
<pre><code class="objective-c">
    self.navigationController.navigationBar.backItem.accessibilityLabel = @"new label for the back button";
</code></pre><pre><code class="swift">
<pre><code>navigationController?.navigationBar.backItem?.accessibilityLabel = &quot;new label for the back button&quot;</code></pre><p></code></pre></p>
<p></br>The customization of this element often consists in <strong>displaying a single disclosure indicator with no text</strong>.
</br><img alt="" style="max-width: 400px; height: auto; " src="./images/iOSdev/NavigationBar_2.png" />
</br>The two possible achievements that are detailed in the following examples are based on the standard component replacement by a customized <strong>UIBarButtonItem</strong> with a simple <strong>image as an incoming parameter</strong> for the disclosure indicator: </p>
<pre><code class="objective-c">
    UIBarButtonItem &#42; _a11yLeftBarButton;

    _a11yLeftBarButton = [[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@"imgInfo"]
                                                         style:UIBarButtonItemStyleDone
                                                        target:self
                                                        action:@selector(goBackToThePreviousView:)];

    _a11yLeftBarButton.accessibilityLabel = @"previous screen";
    self.navigationItem.leftBarButtonItem = _a11yLeftBarButton;
</code></pre><pre><code class="swift">
<pre><code>var a11yLeftBarButton: UIBarButtonItem?

a11yLeftBarButton = UIBarButtonItem(image: UIImage(named: &quot;imgInfo&quot;),
                                    style: .done,
                                    target: self,
                                    action: #selector(goBackToThePreviousView(info:)))

a11yLeftBarButton!.accessibilityLabel = &quot;previous screen&quot;
navigationItem.leftBarButtonItem = a11yLeftBarButton</code></pre><p></code></pre></p>
<p></br>... or on a <strong>UIView</strong> with an added gesture recognizer to define the action of this element: it&#39;s a little bit longer than the previous one but it has the advantage of <strong>providing a frame</strong> whose interest will be enlighted if the reading order of the page items will include those of the navigation bar for instance.</p>
<pre><code class="objective-c">
    var a11yLeftBarButton: UIBarButtonItem?

    UIImage &#42; img = [UIImage imageNamed:@"imgInfo"];
    UIImageView &#42; imgView = [[UIImageView alloc]initWithImage:img];
    _a11yLeftBarButton = [[UIBarButtonItem alloc]initWithCustomView:imgView];

    UITapGestureRecognizer &#42; tap = [[UITapGestureRecognizer alloc]initWithTarget:self
                                                                          action:@selector(goBackToThePreviousView:)];
    [_a11yLeftBarButton.customView addGestureRecognizer:tap];

    _a11yLeftBarButton.isAccessibilityElement = YES;
    _a11yLeftBarButton.accessibilityTraits = UIAccessibilityTraitButton;
    _a11yLeftBarButton.accessibilityLabel = @"previous screen";

    self.navigationItem.leftBarButtonItem = _a11yLeftBarButton;
</code></pre><pre><code class="swift">
<pre><code>var a11yLeftBarButton: UIBarButtonItem?

let a11yLeftBarButtonImage = UIImage(named: &quot;imgInfo&quot;)
a11yLeftBarButton = UIBarButtonItem(customView: UIImageView(image: a11yLeftBarButtonImage))

let tap = UITapGestureRecognizer(target: self,
                                 action: #selector(goBackToThePreviousView(info:)))
a11yLeftBarButton?.customView?.addGestureRecognizer(tap)

a11yLeftBarButton?.isAccessibilityElement = true
a11yLeftBarButton?.accessibilityTraits = .button
a11yLeftBarButton?.accessibilityLabel = &quot;previous screen&quot;

navigationItem.leftBarButtonItem = a11yLeftBarButton</code></pre><p></code></pre></p>
<p></br>Then, the chosen implementation will depend on the purpose of the new created element.</p>
</div>
<div class="tab-pane" id="navBar-Title" role="tabpanel" >
In order to have a quick access to the accessibility properties of a navigation bar title item, it's recommended to **implement its content in UIView form**:

<pre><code class="objective-c">
    UILabel &#42; a11yTitleLabel = [[UILabel alloc]init];
    a11yTitleLabel.text = @"TITLE";
    [a11yTitleLabel sizeToFit];

    self.navigationItem.titleView = a11yTitleLabel;
    self.navigationItem.titleView.accessibilityLabel = @"writing and reading out are different";
</code></pre><pre><code class="swift">
<pre><code>let a11yTitleLabel = UILabel()
a11yTitleLabel.text = &quot;TITLE&quot;
a11yTitleLabel.sizeToFit()

navigationItem.titleView = a11yTitleLabel
navigationItem.titleView?.accessibilityLabel = &quot;writing and reading out are different&quot;</code></pre><p></code></pre></p>
</div>
<div class="tab-pane" id="navBar-RightBarItem" role="tabpanel">
</br><img alt="" style="max-width: 400px; height: auto; " src="./images/iOSdev/NavigationBar_3.png" />
</br>**Using UIView is recommended** when new elements are created in the right part of the navigation bar so as to ease some VoiceOver future implementations.
<pre><code class="objective-c">
    UIBarButtonItem &#42; _a11yRightBarButton;

<pre><code>UILabel &amp;#42; a11y = [[UILabel alloc]init];
a11y.text = @&quot;OK&quot;;
[a11y sizeToFit];
[a11y setUserInteractionEnabled:YES]; //Mandatory to use the &#39;tap gesture&#39;.

_a11yRightBarButton = [[UIBarButtonItem alloc]initWithCustomView:a11y];

UITapGestureRecognizer &amp;#42; tap = [[UITapGestureRecognizer alloc]initWithTarget:self 
                                                                      action:@selector(validateActions:)];
[_a11yRightBarButton.customView addGestureRecognizer:tap];

_a11yRightBarButton.isAccessibilityElement = YES;
_a11yRightBarButton.accessibilityTraits = UIAccessibilityTraitButton;
_a11yRightBarButton.accessibilityLabel = @&quot;validate your actions&quot;;

self.navigationItem.rightBarButtonItem = _a11yRightBarButton;</code></pre><p></code></pre><pre><code class="swift">
    var a11yRightBarButton: UIBarButtonItem?</p>
<pre><code>let a11y = UILabel()
a11y.text = &quot;OK&quot;
a11y.sizeToFit()
a11y.isUserInteractionEnabled = true //Mandatory to use the &#39;tap gesture&#39;.

a11yRightBarButton = UIBarButtonItem(customView: a11y)

let tap = UITapGestureRecognizer(target: self,
                                 action: #selector(validateActions(info:)))
a11yRightBarButton?.customView?.addGestureRecognizer(tap)

a11yRightBarButton?.isAccessibilityElement = true
a11yRightBarButton?.accessibilityTraits = .button
a11yRightBarButton?.accessibilityLabel = &quot;validate your actions&quot;

navigationItem.rightBarButtonItem = a11yRightBarButton</code></pre><p></code></pre></p>
</div>
<div class="tab-pane" id="navBar-ReadingOrder" role="tabpanel">
Usually, we don't need to change the VoiceOver reading order for the navigation bar items but it's sometimes necessary ⟹ tutorial page whose `RightBarItem` triggers the display of the next page for instance.
</br></br>As an example, let's assume that the `RightBarItem` must be the last focused element thanks to one-finger left flicks in order to illustrate a reading order modification that involves the navigation bar items.
</br></br>The proposed page will be composed of the following elements:
<ul>
  <li>A navigation bar with a disclosure indicator *(LeftBarItem)*, a title and a 'OK' button *(RightBarItem)*.</li>
  <li>Five not consecutive labels.</li>
  <li>An 'ACTION' button that is horizontally and vertically centered.</li>
</ul>
<img alt="" style="max-width: 200px; height: auto; " src="./images/iOSdev/NavigationBar_4.png" />
</br>The rationale behind this presentation is to follow this order: LeftBarItem, title, Label1, Label2, Label3, 'ACTION' button, Label4, Label5 and RightBarItem.
</br></br>First of all, the navigation bar items are customized thanks to the code examples provided in the other sheets of this section.
<pre><code class="objective-c">
@interface NavigationBarReadingOrder() {
    UIBarButtonItem &#42; _a11yLeftBarButton;
    UIView &#42; _a11yBarTitle;
    UIBarButtonItem &#42; _a11yRightBarButton;
}
@end


<p>@implementation NavigationBarReadingOrder</p>
<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>
<p>  [self setBackItem];
  [self setTitle];
  [self setNextPageBarButton];
}</p>
</li>
</ul>
<ul>
<li><p>(void)setBackItem {</p>
<p>  UIImage &#42; img = [UIImage imageNamed:@&quot;infoImg&quot;];
  UIImageView &#42; imgView = [[UIImageView alloc]initWithImage:img];
  _a11yLeftBarButton = [[UIBarButtonItem alloc]initWithCustomView:imgView];</p>
<p>  UITapGestureRecognizer &#42; tap = [[UITapGestureRecognizer alloc]initWithTarget:self</p>
<pre><code>                                                                    action:@selector(goBackToThePreviousView:)];</code></pre><p>  [_a11yLeftBarButton.customView addGestureRecognizer:tap];</p>
<p>  self.navigationItem.leftBarButtonItem = _a11yLeftBarButton;
}</p>
</li>
</ul>
<ul>
<li><p>(void)setTitle {</p>
<p>  UILabel &#42; a11yTitleLabel = [[UILabel alloc]init];
  a11yTitleLabel.text = @&quot;TITLE&quot;;
  [a11yTitleLabel sizeToFit];</p>
<p>  self.navigationItem.titleView = a11yTitleLabel;
  _a11yBarTitle = self.navigationItem.titleView;
}</p>
</li>
</ul>
<ul>
<li><p>(void)setNextPageBarButton {</p>
<p>  UILabel &#42; a11y = [[UILabel alloc]init];
  a11y.text = @&quot;OK&quot;;
  [a11y sizeToFit];
  [a11y setUserInteractionEnabled:YES];</p>
<p>  _a11yRightBarButton = [[UIBarButtonItem alloc]initWithCustomView:a11y];</p>
<p>  UITapGestureRecognizer &#42; tap = [[UITapGestureRecognizer alloc]initWithTarget:self</p>
<pre><code>                                                                    action:@selector(validateActions:)];</code></pre><p>  [_a11yRightBarButton.customView addGestureRecognizer:tap];</p>
<p>  self.navigationItem.rightBarButtonItem = _a11yRightBarButton;
}
@end
</code></pre><pre><code class="swift">
class OrderViewController: UIViewController {</p>
<p>  var a11yLeftBarButton: UIBarButtonItem?
  var a11yBarTitle: UIView?
  var a11yRightBarButton: UIBarButtonItem?</p>
<p>  override func viewDidLoad() {</p>
<pre><code>  super.viewDidLoad()

  setBackItem()
  setTitle()
  setNextPageBarButton()</code></pre><p>  }</p>
<p>  private func setBackItem() {</p>
<pre><code>  let a11yLeftBarButtonImage = UIImage(named: &quot;infoImg&quot;)
  a11yLeftBarButton = UIBarButtonItem(customView: UIImageView(image: a11yLeftBarButtonImage))

  let tap = UITapGestureRecognizer(target: self,
                                   action: #selector(goBackToThePreviousView(info:)))
  a11yLeftBarButton?.customView?.addGestureRecognizer(tap)

  navigationItem.leftBarButtonItem = a11yLeftBarButton</code></pre><p>  }</p>
<p>  private func setTitle() {</p>
<pre><code>  let a11yTitleLabel = UILabel()
  a11yTitleLabel.text = &quot;TITLE&quot;
  a11yTitleLabel.sizeToFit()

  navigationItem.titleView = a11yTitleLabel
  a11yBarTitle = navigationItem.titleView</code></pre><p>  }</p>
<p>  private func setNextPageBarButton() {</p>
<pre><code>  let a11y = UILabel()
  a11y.text = &quot;OK&quot;
  a11y.sizeToFit()
  a11y.isUserInteractionEnabled = true

  a11yRightBarButton = UIBarButtonItem(customView: a11y)

  let tap = UITapGestureRecognizer(target: self,
                                   action: #selector(goToTheNextPage(info:)))
  a11yRightBarButton?.customView?.addGestureRecognizer(tap)

  navigationItem.rightBarButtonItem = a11yRightBarButton</code></pre><p>  }
}
</code></pre></p>
</li>
</ul>
<p></br>Next, we <strong>create accessible elements</strong> for the navigation bar and we <strong>define the VoiceOver reading order</strong> for the entire page thanks to its <code>accessibilityElements</code> array.
</br>The entire page and the navigation bar are two different containers that lead to <strong>hiding to VoiceOver the navigation bar native items</strong> and to transfer them to the page view with the focus appropriate coordinates.</p>
<pre><code class="objective-c">
@interface NavigationBarReadingOrder() {
    UIBarButtonItem &#42; _a11yLeftBarButton;
    UIView &#42; _a11yBarTitle;
    UIBarButtonItem &#42; _a11yRightBarButton;
}

@property (weak, nonatomic) IBOutlet UILabel &#42; a11yLabel1;
@property (weak, nonatomic) IBOutlet UILabel &#42; a11yLabel2;
@property (weak, nonatomic) IBOutlet UILabel &#42; a11yLabel3;
@property (weak, nonatomic) IBOutlet UILabel &#42; a11yLabel4;
@property (weak, nonatomic) IBOutlet UILabel &#42; a11yLabel5;
@property (weak, nonatomic) IBOutlet UIButton &#42; a11yCentralButton;

@end


@implementation NavigationBarReadingOrder

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

    [self createA11yElts];
    self.navigationController.navigationBar.accessibilityElementsHidden = YES;
}


- (void)createA11yElts {

    UIView &#42; navBarView = [[[_a11yBarTitle superview] superview] superview];

    UIView &#42; leftButtonView = [_a11yLeftBarButton valueForKey:@"view"];
    UIAccessibilityElement * a11yLBB = [[UIAccessibilityElement alloc] initWithAccessibilityContainer:self.view];
    a11yLBB.accessibilityFrameInContainerSpace = [navBarView convertRect:[[leftButtonView superview] superview].frame toView:self.view];
    a11yLBB.accessibilityLabel = @"previous screen";
    a11yLBB.accessibilityTraits = UIAccessibilityTraitButton;

    UIAccessibilityElement &#42; a11yTBV = [[UIAccessibilityElement alloc] initWithAccessibilityContainer:self.view];
    a11yTBV.accessibilityFrameInContainerSpace = [navBarView convertRect:[self.navigationItem.titleView superview].frame toView:self.view];
    a11yTBV.accessibilityLabel = @"writing and reading out are different";
    a11yTBV.accessibilityTraits = UIAccessibilityTraitHeader;

    UIView &#42; rightButtonView = [_a11yRightBarButton valueForKey:@"view"];
    UIAccessibilityElement &#42; a11yRBB = [[UIAccessibilityElement alloc] initWithAccessibilityContainer:self.view];
    a11yRBB.accessibilityFrameInContainerSpace = [navBarView convertRect:[[rightButtonView superview] superview].frame toView:self.view];
    a11yRBB.accessibilityLabel = @"next screen";
    a11yRBB.accessibilityTraits = UIAccessibilityTraitButton;

    self.view.accessibilityElements = @[a11yLBB,
                                        a11yTBV,
                                        _a11yLabel1,
                                        _a11yLabel2,
                                        _a11yLabel3,
                                        _a11yCentralButton,
                                        _a11yLabel4,
                                        _a11yLabel5,
                                        a11yRBB];
}
@end

</code></pre><pre><code class="swift">
<p>@IBOutlet weak var a11yLabel1: UILabel!
@IBOutlet weak var a11yLabel2: UILabel!
@IBOutlet weak var a11yLabel3: UILabel!
@IBOutlet weak var a11yLabel4: UILabel!
@IBOutlet weak var a11yLabel5: UILabel!
@IBOutlet weak var a11yCentralButton: UIButton!</p>
<p>override func viewDidAppear(&#95; animated: Bool) {
    super.viewDidAppear(animated)</p>
<pre><code>createA11yElts()
navigationController?.navigationBar.accessibilityElementsHidden = true</code></pre><p>}</p>
<p>private func createA11yElts() {</p>
<pre><code>let navBarView = a11yBarTitle?.superview?.superview?.superview

let leftButtonView = a11yLeftBarButton?.value(forKey: &quot;view&quot;) as? UIView
let a11yLBB = UIAccessibilityElement(accessibilityContainer: self.view!)
a11yLBB.accessibilityFrameInContainerSpace = navBarView!.convert((leftButtonView?.superview?.superview!.frame)!,to:self.view)
a11yLBB.accessibilityLabel = &quot;previous screen&quot;
a11yLBB.accessibilityTraits = .button

let a11yTBV = UIAccessibilityElement(accessibilityContainer: self.view!)
a11yTBV.accessibilityFrameInContainerSpace = navBarView!.convert((navigationItem.titleView?.superview!.frame)!,to:self.view)
a11yTBV.accessibilityLabel = &quot;writing and reading out are different&quot;
a11yTBV.accessibilityTraits = .header

let rightButtonView = a11yRightBarButton?.value(forKey: &quot;view&quot;) as? UIView
let a11yRBB = UIAccessibilityElement(accessibilityContainer: self.view!)
a11yRBB.accessibilityFrameInContainerSpace = navBarView!.convert((rightButtonView?.superview?.superview!.frame)!,to:self.view)
a11yRBB.accessibilityLabel = &quot;next screen&quot;
a11yRBB.accessibilityTraits = .button

self.view.accessibilityElements = [a11yLBB,
                                   a11yTBV,
                                   a11yLabel1!,
                                   a11yLabel2!,
                                   a11yLabel3!,
                                   a11yCentralButton!,
                                   a11yLabel4!,
                                   a11yLabel5!,
                                   a11yRBB]</code></pre><p>}
</code></pre></p>
<p></br>The result corresponds to the desired reading order using successive one-finger flicks to select the different accessible elements.
</br><img alt="" style="max-width: 1000px; height: auto; " src="./images/iOSdev/NavigationBar_5.png" />
</br><img alt="" style="max-width: 1000px; height: auto; " src="./images/iOSdev/NavigationBar_6.png" /></p>
</div>
<div class="tab-pane" id="navBar-Link" role="tabpanel">
- [UINavigationBar](https://developer.apple.com/documentation/uikit/uinavigationbar)
</div>
</div>
</br></br>
<h2 id="speech-synthesis">Speech synthesis</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#speechSyn-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#speechSyn-Details" 
           role="tab" 
           aria-selected="false">Details</a>
    </li>
    <li class="nav-item">
        <a class="nav-link"
           data-toggle="tab" 
           href="#speechSyn-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#speechSyn-Phonemes" 
           role="tab" 
           aria-selected="false">Phonemes</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#speechSyn-Links" 
           role="tab" 
           aria-selected="false">Links</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="speechSyn-Description"
     role="tabpanel">
Many [use cases](./dev-ios-wwdc-18236.html#Uses) are good candidates to use the speech synthesis and they aren't necessary all part of accessibility.
</br></br>However, in that perspective, it's important to note that this **feature doesn't replace VoiceOver** but could be a good complement to the screen reader implementation *(the speech overlaps the screen reader voice)*.

</div>
<div class="tab-pane" id="speechSyn-Details" role="tabpanel">
Few elements are mandatory to create a speech synthesis on the fly:
<ul>
  <li>**The text**: `AVSpeechUtterance` instance with a `voice` property that's `AVSpeechSynthesisVoice` typed.</li>
  <li>**The synthesizer**: `AVSpeechSynthesizer` instance that handles the incoming text with an events control thanks to the `AVSpeechSynthesizerDelegate` protocol.</li>
</ul>
<img alt="" style="max-width: 800px; height: auto; " src="./images/iOSdev/SpeechSynthesizer.png" />
</div>
<div class="tab-pane" id="speechSyn-Example" role="tabpanel">
To be sure that a bunch of `AVSpeechUtterance` instances is entirely vocalized, it's [essential](./dev-ios-wwdc-18236.html#Basics) to retain the `AVSpeechSynthesizer` instance until the speech is done.
</br></br>The following example will define the speech rate and the voice pitch/volume for each utterance while:
<ul>
  <li>Highlighting the vocalized word thanks to the `AVSpeechSynthesizerDelegate` protocol.</li>
  <li>Pausing and resuming from where the speech stopped thanks to some `AVSpeechSynthesizer` instance methods.</li>
</ul>

<pre><code class="objective-c">
@interface SpeechSynthesis()  <AVSpeechSynthesizerDelegate> {

    NSMutableArray * playerQueue;
    AVSpeechSynthesizer * synthesizer;
    __weak IBOutlet UILabel * textLabel;
}
@end

NS_ASSUME_NONNULL_BEGIN
@implementation SpeechSynthesis

- (void)viewDidLoad {
    [super viewDidLoad];

    playerQueue = [[NSMutableArray alloc] init];
    synthesizer = [[AVSpeechSynthesizer alloc] init];
}

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

    for (int i = 1 ; i < 11 ; i++) {

        NSString * stringNbPrefix = @"Sentence number ";
        NSString * stringNbSuffix = @" of the speech synthesizer.";
        NSString * stringNb = [NSString stringWithFormat:@"%@%i%@", stringNbPrefix, i, stringNbSuffix];

        AVSpeechUtterance * utterance = [[AVSpeechUtterance alloc] initWithString:stringNb];
        utterance.rate = AVSpeechUtteranceDefaultSpeechRate;
        utterance.pitchMultiplier = 1.0;
        utterance.volume = 1.0;

        [playerQueue addObject:utterance];
    }

    synthesizer.delegate = self;

    for (AVSpeechUtterance * utterance in playerQueue) {
        [synthesizer speakUtterance:utterance];
    }
}

//AVSpeechSynthesizerDelegate protocol method to highlight the vocalized word.
- (void)speechSynthesizer:(AVSpeechSynthesizer *)synthesizer
willSpeakRangeOfSpeechString:(NSRange)characterRange
                utterance:(AVSpeechUtterance *)utterance {

    NSMutableAttributedString * attributedString = [[NSMutableAttributedString alloc] initWithString:utterance.speechString];

    [attributedString addAttribute:NSFontAttributeName
                             value:[UIFont systemFontOfSize:19.0]
                             range:characterRange];

    NSAttributedString * subString = [attributedString attributedSubstringFromRange:characterRange];
    textLabel.attributedText = attributedString;

    NSString * output = [NSString stringWithFormat:@"%@%@", @"word : ", subString.string];
    NSLog(@"%@", output);
}

- (IBAction)pauseButton:(UIButton *)sender {

    if (synthesizer.isSpeaking == TRUE) {
        if ([synthesizer pauseSpeakingAtBoundary:AVSpeechBoundaryImmediate] == TRUE) {
            NSLog(@"PAUSE");
        } else {
            NSLog(@"P.R.O.B.L.E.M. when pausing.");
        }
    }
}

- (IBAction)resumeButton:(UIButton *)sender {

    if (synthesizer.isPaused == TRUE) {
        if ([synthesizer continueSpeaking] == TRUE) {
            NSLog(@"RESUME");
        } else {
            NSLog(@"P.R.O.B.L.E.M. when resuming.");
        }
    }
}
@end
</code></pre><pre><code class="swift">
<p>class SpeechSynthesis: UIViewController, AVSpeechSynthesizerDelegate {</p>
<pre><code>@IBOutlet weak var textLabel: UILabel!

var synthesizer = AVSpeechSynthesizer()
var playQueue = [AVSpeechUtterance]()


override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    for i in 1...10 {

        let stringNb = &quot;Sentence number &quot; + String(i) + &quot; of the speech synthesizer.&quot;

        let utterance = AVSpeechUtterance(string: stringNb)
        utterance.rate = AVSpeechUtteranceDefaultSpeechRate
        utterance.pitchMultiplier = 1.0
        utterance.volume = 1.0

        playQueue.append(utterance)
    }

    synthesizer.delegate = self

    for utterance in playQueue {
        synthesizer.speak(utterance)
    }
}

//AVSpeechSynthesizerDelegate protocol method to highlight the vocalized word.
func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer,
                       willSpeakRangeOfSpeechString characterRange: NSRange,
                       utterance: AVSpeechUtterance) {

    let attributedString = NSMutableAttributedString(string: utterance.speechString)
    attributedString.addAttribute(.font,
                                  value: UIFont.boldSystemFont(ofSize: 19),
                                  range: characterRange)

    textLabel.attributedText = attributedString

    let subString = attributedString.attributedSubstring(from: characterRange)
    print(&quot;word : \(subString.string)&quot;)
}


@IBAction func pauseAction(_ sender: UIButton) {

    if (synthesizer.isSpeaking == true) {
        if (synthesizer.pauseSpeaking(at: .immediate) == true) {
            print(&quot;PAUSE&quot;)
        } else {
            print(&quot;P.R.O.B.L.E.M. when pausing.&quot;)
        }
    }
}


@IBAction func resumeAction(_ sender: UIButton) {

    if (synthesizer.isPaused == true) {
        if (synthesizer.continueSpeaking() == true) {
            print(&quot;RESUME&quot;)
        } else {
            print(&quot;P.R.O.B.L.E.M. when resuming.&quot;)
        }
    }
}</code></pre><p>}
</code></pre></p>
</div>
<div class="tab-pane" id="speechSyn-Phonemes" role="tabpanel">
When a particular spelling is intended, phonetics is highly recommended to get the desired purpose.

<pre><code class="objective-c">
    NSMutableAttributedString &#42; attrStr = [[NSMutableAttributedString alloc] initWithString:@"blablabla" 
                                                                             attributes:@{AVSpeechSynthesisIPANotationAttribute:@"ˈma͡ɪ.ˈa͡ɪ.ˈfʌ.ˈniz.ˈgɻe͡ɪt"}];

    AVSpeechUtterance &#42; utterance = [[AVSpeechUtterance alloc] initWithAttributedString:attrStr];

    AVSpeechSynthesizer &#42; synthesizer = [[AVSpeechSynthesizer alloc] init];
    [synthesizer speakUtterance:utterance];
</code></pre><pre><code class="swift">
<pre><code>    let pronunciationKey = NSAttributedString.Key(rawValue: AVSpeechSynthesisIPANotationAttribute)

    let attrStr = NSMutableAttributedString(string: &quot;blablabla&quot;,
                                            attributes: [pronunciationKey: &quot;ˈma͡ɪ.ˈa͡ɪ.ˈfʌ.ˈniz.ˈgɻe͡ɪt&quot;])

    let utterance = AVSpeechUtterance(attributedString: attrStr)

    let synthesizer = AVSpeechSynthesizer()
    synthesizer.speak(utterance)</code></pre><p></code></pre></p>
<p></br>Generating phonetics may be done in the device settings.
</br><img alt="" style="max-width: 1100px; height: auto; " src="./images/iOSdev/SpeechSynthesizerEx_1.png" />
</br>Once the menu <code>General</code> - <code>Accessibility</code> - <code>Speech</code> - <code>Pronunciations</code> is reached...
</br><img alt="" style="max-width: 1100px; height: auto; " src="./images/iOSdev/SpeechSynthesizerEx_2.png" /></br></br></p>
<ol>
  <li>Select the '**+**' icon to add a new phonetic element.</li>
  <li>Name this new element in order to quickly find it later on.</li>
  <li>Tap the **microphone** icon.</li>
  <li>Vocalize an entire sentence or a single word.</li>
  <li>Listen to the different system proposals.</li>
  <li>Validate your choice with the '**OK**' button or cancel to start over.</li>
  <li>Tap the back button to confirm the new created phonetic element.</li>
  <li>Find all the generated elements in the `Pronunciations` page.</li>
</ol>

<img alt="" style="max-width: 1100px; height: auto; " src="./images/iOSdev/SpeechSynthesizerEx_3.png"/>
</br>To get the phonetic expression inside the code, pass it through the mobile `Notes` application to be synchronized with the iCloud one from which a copy-paste becomes easy as a pie.
</div>
<div class="tab-pane" id="speechSyn-Links" role="tabpanel">
<ul>
  <li>[AVSpeechSynthesisVoice](https://developer.apple.com/documentation/avfoundation/avspeechsynthesisvoice)</li>
  <li>[AVSpeechSynthesizer](https://developer.apple.com/documentation/avfoundation/avspeechsynthesizer)</li>
  <li>[AVSpeechSynthesizerDelegate](https://developer.apple.com/documentation/avfoundation/avspeechsynthesizerdelegate)</li>
  <li>[AVSpeechUtterance](https://developer.apple.com/documentation/avfoundation/avspeechutterance) </li>
</ul>
</div>
</div>

<p>All the speech synthesizer functionalities are introduced in a <a href="./dev-ios-wwdc-18236.html">WWDC 2018 video</a> that&#39;s perfectly summarized in the WWDC section of this site.
</br></br></p>
<h2 id="switch-control">Switch Control</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#switchCtrl-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#switchCtrl-Custom" 
           role="tab" 
           aria-selected="false">Item mode customization</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#switchCtrl-Link" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="switchCtrl-Description"
     role="tabpanel">
The accessibility Switch Control feature revolves around the point mode and the item mode.
</br><img alt="accessibility switch control screenshots" style="max-width: 700px; height: auto; " src="./images/iOSdev/SwitchControl.png" />
</br>The element selection using the item mode works fine when the user interface isn't too complicated and uses native elements.
</br>However, this mode may not be helpful according to the rationale behind some specific use cases and then needs to be customized.
</div>
<div class="tab-pane" id="switchCtrl-Custom" role="tabpanel">
The Xcode InterfaceBuilder shows the structure used for the example hereunder :
</br><img alt="xcode screenshot" style="max-width: 700px; height: auto; " src="./images/iOSdev/SwitchControlIB.png" />
</br>The following steps represent the customization :
- Creation of 2 groups {Test_1 + Test_2 ; Btn 5 + Btn 6} that must be selectable in the item mode.
- Within the other elements, only Btn 1 et Btn 2 must be separately accessible.

<pre><code class="objective-c">
@interface ViewController2 ()

@property (weak, nonatomic) IBOutlet UIStackView * btnsParentView;
@property (weak, nonatomic) IBOutlet UIButton * btn1;
@property (weak, nonatomic) IBOutlet UIButton * btn2;
@property (weak, nonatomic) IBOutlet UIButton * btn5;
@property (weak, nonatomic) IBOutlet UIButton * btn6;

@end


@implementation ViewController2
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

    //Creation of the first group 'testWrap' COMBINING the 'Test_1' and 'Test_2' buttons.
    UIButton * testOneButton = [self.view viewWithTag:1];
    UIButton * testTwoButton = [self.view viewWithTag:2];
    CGRect testWrapFrame = CGRectUnion(testOneButton.frame, testTwoButton.frame);

    UIAccessibilityElement * testWrap = [[UIAccessibilityElement alloc]initWithAccessibilityContainer:self.view];

    testWrap.isAccessibilityElement = false;
    testWrap.accessibilityFrame = testWrapFrame;
    testWrap.accessibilityNavigationStyle = UIAccessibilityNavigationStyleCombined; //Property specific to Switch Control.
    testWrap.accessibilityElements = @[testOneButton, testTwoButton];


    //Creation of the 'secondGroup' SEPARATING the first two buttons.
    CGRect secondGroupRect = CGRectUnion(_btn1.frame, _btn2.frame);
    CGRect secondGroupFrame = [_btnsParentView convertRect:secondGroupRect
                                                    toView:self.view];
    UIAccessibilityElement * secondGroup = [[UIAccessibilityElement alloc]initWithAccessibilityContainer:_btnsParentView];

    secondGroup.isAccessibilityElement = false;
    secondGroup.accessibilityFrame = secondGroupFrame;
    secondGroup.accessibilityNavigationStyle = UIAccessibilityNavigationStyleSeparate;
    secondGroup.accessibilityElements = @[_btn1, _btn2];


    //Creation of the 'thirdGroup' COMBINING the last two buttons.
    CGRect thirdGroupRect = CGRectUnion(_btn5.frame, _btn6.frame);
    CGRect thirdGroupFrame = [_btnsParentView convertRect:thirdGroupRect
                                                   toView:self.view];
    UIAccessibilityElement * thirdGroup = [[UIAccessibilityElement alloc]initWithAccessibilityContainer:_btnsParentView];

    thirdGroup.isAccessibilityElement = false;
    thirdGroup.accessibilityFrame = thirdGroupFrame;
    thirdGroup.accessibilityNavigationStyle = UIAccessibilityNavigationStyleCombined;
    thirdGroup.accessibilityElements = @[_btn5, _btn6];


    self.view.accessibilityElements = @[testWrap, 
                                        secondGroup, 
                                        thirdGroup];
}
@end
</code></pre><pre><code class="swift">
<p>class ViewController: UIViewController {</p>
<pre><code>@IBOutlet weak var btnsParentView: UIStackView!
@IBOutlet weak var btn1: UIButton!
@IBOutlet weak var btn2: UIButton!
@IBOutlet weak var btn5: UIButton!
@IBOutlet weak var btn6: UIButton!


override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    //Creation of the first group &#39;testWrap&#39; COMBINING the &#39;Test_1&#39; and &#39;Test_2&#39; buttons.
    let testOneButton = self.view.viewWithTag(1) as? UIButton
    let testTwoButton = self.view.viewWithTag(2) as? UIButton
    let testWrapFrame = testOneButton?.frame.union((testTwoButton?.frame)!)

    let testWrap = UIAccessibilityElement(accessibilityContainer: self.view!)

    testWrap.isAccessibilityElement = false
    testWrap.accessibilityFrame = testWrapFrame!
    testWrap.accessibilityNavigationStyle = .combined   //Property specific to Switch Control.
    testWrap.accessibilityElements = [testOneButton!, testTwoButton!]


    //Creation of the &#39;secondGroup&#39; SEPARATING the first two buttons.
    let secondGroupRect = btn1.frame.union(btn2.frame)
    let secondGroupFrame = btnsParentView.convert(secondGroupRect,
                                                  to: self.view)
    let secondGroup = UIAccessibilityElement(accessibilityContainer: btnsParentView!)

    secondGroup.isAccessibilityElement = false
    secondGroup.accessibilityFrame = secondGroupFrame
    secondGroup.accessibilityNavigationStyle = .separate
    secondGroup.accessibilityElements = [btn1!, btn2!]


    //Creation of the &#39;thirdGroup&#39; COMBINING the last two buttons.
    let thirdGroupRect = btn5.frame.union(btn6.frame)
    let thirdGroupFrame = btnsParentView.convert(thirdGroupRect,
                                                 to: self.view)
    let thirdGroup = UIAccessibilityElement(accessibilityContainer: btnsParentView!)

    thirdGroup.isAccessibilityElement = false
    thirdGroup.accessibilityFrame = thirdGroupFrame
    thirdGroup.accessibilityNavigationStyle = .combined
    thirdGroup.accessibilityElements = [btn5!, btn6!]


    self.view.accessibilityElements = [testWrap,
                                       secondGroup, 
                                       thirdGroup]
}</code></pre><p>}
</code></pre></p>
<p></br>The visual rendering is exposed hereunder :
</br><img alt="visual rendering screenshot" style="max-width: 1100px; height: auto; " src="./images/iOSdev/SwitchControl_1.png" />
</br>Once activated, the created groups allow to reach directly the elements which they contain.</p>
</div>
<div class="tab-pane" id="switchCtrl-Link" role="tabpanel">
- [`accessibilityNavigationStyle`](https://developer.apple.com/documentation/objectivec/nsobject/1615200-accessibilitynavigationstyle)
</div>
</div></br></br>
<h2 id="vocalized-application-name">Vocalized application name</h2>
<ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
        <a class="nav-link active"
           data-toggle="tab" 
           href="#appName-Description" 
           role="tab" 
           aria-selected="true">Description</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#appName-Example" 
           role="tab" 
           aria-selected="false">Example</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" 
           data-toggle="tab" 
           href="#appName-Link" 
           role="tab" 
           aria-selected="false">Link</a>
    </li>
</ul><div class="tab-content">
<div class="tab-pane show active"
     id="appName-Description"
     role="tabpanel">
The same result as the <a href="./voiceover.html#CustomLabel" style="text-decoration: underline;">VoiceOver gesture</a> to set a custom label can be reached by code.
</br>The rationale behind is to render a better vocalisation for an application name that could be very obscure according to its written abbreviation.
</div>
<div class="tab-pane" id="appName-Example" role="tabpanel">
**CFBundleSpokenName** is the property list key that vocally replaces an application name and might take many different translations depending on the foreign languages.
</br><img alt="" style="max-width: 750px; height: auto; " src="./images/iOSdev/AppName_1.png" />
</br>In the end, we go from a weird to an understandable vocalized name that is defined upstream with no user modifications.
</br><img alt="" style="max-width: 600px; height: auto; " src="./images/iOSdev/AppName_2.png" />

</div>
<div class="tab-pane" id="appName-Link" role="tabpanel">
- [`CFBundleSpokenName`](https://developer.apple.com/documentation/bundleresources/information_property_list/cfbundlespokenname)
</div>
</div></br></br>
<!--  This file is part of a11y-guidelines | Our vision of mobile & web accessibility guidelines and best practices, with valid/invalid examples.
 Copyright (C) 2016  Orange SA
 See the Creative Commons Legal Code Attribution-ShareAlike 3.0 Unported License for more details (LICENSE file). -->
          
        </div>
      </div>
    </main>

    <a aria-hidden="true" id="back-to-top" href="#" class="btn btn-primary btn-lg back-to-top" role="button" title="Back to top of page" data-toggle="tooltip" data-placement="left"></a>
        
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.2.0/js/tether.min.js" integrity="sha384-Plbmg8JY28KFelvJVai01l8WyZzrYWG825m+cZ0eDDS1f7d/js6ikvy1+X+guPIB" crossorigin="anonymous"></script>
    <script src="/boosted/js/boosted.min.js"></script>
    <script type="text/javascript" src="/js/reco.js"></script>
    <script type="text/javascript" src="/js/highlight.min.js"></script>
</body>
</html>